     1                                  ;   
     2                                  ;   A raw binary that renders to a qemu vm in real mode
     3                                  ;
     4                                  
     5                                  ; RUN
     6                                  ;
     7                                  ; // source : Claude
     8                                  ; nasm -f bin -o draw.bin boot.asm
     9                                  ; qemu-system-i386 -drive format=raw,file=draw.bin 
    10                                  
    11                                  ; This one from GPT also works! Probably the same BIOS?
    12                                  ; qemu-system-x86_64 -drive format=raw,file=draw.bin // GPT
    13                                  
    14                                  ; DISASSEMBLE
    15                                  ; objdump -b binary -m i386 -D draw.bin
    16                                  
    17                                  
    18                                  
    19                                  %ifdef ELF
    20                                  section .text
    21                                  global _start
    22                                  _start:
    23                                  %else
    24                                  [bits 16]
    25                                  [org 0x7c00]
    26                                  %endif
    27                                  
    28                                  ; variable for boot sector playground
    29 00000000 0000                    boot_x dw 0 ; bugs if defined within boot_sector section
    30                                  
    31                                  
    32                                  
    33                                  ; Boot sector - ran out of boot sector so had to move code to second_sector
    34                                  boot_sector:
    35                                  
    36                                  
    37                                      ; Basic setup
    38 00000002 FA                          cli
    39                                      ; mov ax, 0x0000
    40                                      ; mov cs, ax ; Why doesn't this work? I thought that cs=0 by default, so this should change nothing?
    41 00000003 B80000                      mov ax, 0x0000
    42 00000006 8ED8                        mov ds, ax
    43                                      ; mov ax, 0x0000
    44                                      ; mov es, ax
    45 00000008 8ED0                        mov ss, ax
    46 0000000A BC007C                      mov sp, 0x7C00
    47                                  
    48                                      ; additional segment registers
    49                                      ; NOT currently in use because they did not exists pre 80386
    50 0000000D B80000                      mov ax, 0x0000
    51 00000010 8EE0                        mov fs, ax
    52 00000012 8EE8                        mov gs, ax
    53 00000014 FB                          sti
    54                                  
    55                                      ; Load second stage     : sector # 2-5 = 0x7e00 - 0x85FF
    56 00000015 B402                        mov ah, 0x02            ; BIOS read sector function
    57 00000017 B008                        mov al, 8               ; Number of sectors to read -- INCREASING THIS WAS CRUCIAL IN MOVING BEYOND BOOT SECTOR
    58 00000019 B500                        mov ch, 0               ; Cylinder number
    59 0000001B B102                        mov cl, 2               ; Sector number (1 is boot sector)
    60 0000001D B600                        mov dh, 0               ; Head number
    61 0000001F B280                        mov dl, 0x80            ; Drive number (first hard disk)
    62 00000021 BB[0002]                    mov bx, code_segment    ; Where to load the sector
    63 00000024 CD13                        int 0x13                ; BIOS interrupt to read disk
    64                                  
    65                                      ; Load data             : sector # 6   = 0x0x8600 - 0x87FF
    66                                      ; This section will automatically be
    67 00000026 B402                        mov ah, 0x02            ; BIOS read sector function
    68 00000028 B002                        mov al, 2               ; Number of sectors to read
    69 0000002A B500                        mov ch, 0               ; Cylinder number
    70 0000002C B10A                        mov cl, 10              ; Sector number (2-9 is code)
    71 0000002E B600                        mov dh, 0               ; Head number
    72 00000030 B280                        mov dl, 0x80            ; Drive number (first hard disk)
    73                                      ; mov ax, 0x0000
    74                                      ; mov es, ax          ; segment
    75 00000032 BB008E                      mov bx, 0x8E00          ; make sure data sectors at the end of the main text sections 
    76                                  
    77 00000035 CD13                        int 0x13                ; BIOS interrupt to read disk
    78                                      
    79                                      
    80                                      
    81                                  
    82                                      ;;
    83                                      ;; START - Boot section playground
    84                                      ;;
    85                                  
    86                                  .mode_13h_and_clear:
    87 00000037 B81300                      mov ax, 0x13
    88 0000003A CD10                        int 0x10
    89                                  
    90 0000003C B406                        mov ah, 0x06    ; Scroll up function
    91 0000003E B000                        mov al, 0       ; Clear entire screen
    92 00000040 B70C                        mov bh, 0x0C    ; Light Red 
    93 00000042 B500                        mov ch, 0       ; Upper left row
    94 00000044 B100                        mov cl, 0       ; Upper left column
    95 00000046 B618                        mov dh, 24      ; Lower right row
    96 00000048 B24F                        mov dl, 79      ; Lower right column
    97 0000004A CD10                        int 0x10        ; Call BIOS video interrupt
    98                                  
    99                                      ; Landing buffer
   100 0000004C B80000                      mov ax, 0x0000
   101 0000004F B80000                      mov ax, 0x0000
   102 00000052 B80000                      mov ax, 0x0000
   103 00000055 B80000                      mov ax, 0x0000
   104 00000058 B80000                      mov ax, 0x0000
   105 0000005B B80000                      mov ax, 0x0000
   106 0000005E B80000                      mov ax, 0x0000
   107 00000061 B80000                      mov ax, 0x0000
   108 00000064 B80000                      mov ax, 0x0000
   109 00000067 B80000                      mov ax, 0x0000
   110 0000006A B80000                      mov ax, 0x0000
   111 0000006D B80000                      mov ax, 0x0000
   112                                  
   113                                  
   114                                      ; draw pixel
   115 00000070 B40C                        mov ah, 0x0C  ; BIOS video function: write pixel
   116 00000072 B00F                        mov al, 0x0F  ; White color
   117 00000074 31C9                        xor cx, cx
   118 00000076 31D2                        xor dx, dx
   119 00000078 FF06[0000]                  inc word [boot_x]
   120 0000007C 813E[0000]0019              cmp word [boot_x], 6400 ; number of iterations and pixels draw until progressing past boot sector
   121 00000082 7D0E                        jge .load_code_segment
   122 00000084 8B0E[0000]                  mov cx, [boot_x]  ; x
   123 00000088 BA0A00                      mov dx, 10  ; y
   124 0000008B CD10                        int 0x10
   125                                  
   126                                      ; jump back into landing buffer
   127                                      ; jmp 0x0000:0x7C25
   128 0000008D EA607C0000                  jmp 0x0000:0x7C60
   129                                      ; jmp 0x0000:0x7C70
   130                                  
   131                                      ;;
   132                                      ;; END - Boot section playground
   133                                      ;;
   134                                  
   135                                  
   136                                      ; mov al, 0x00       ; Exit QEMU with status 0
   137                                      ; out 0x501, al      ; Write to QEMU's debug exit port
   138                                  
   139                                      .load_code_segment:
   140                                      
   141                                      ; jump to segment 2
   142                                      ; jmp 0x0000:0x7E00
   143 00000092 E96B01                      jmp code_segment
   144                                  
   145                                  
   146                                  
   147                                  %ifndef ELF
   148 00000095 00<rep 169h>            times 510-($-$$) db 0
   149 000001FE 55AA                    dw 0xaa55
   150                                  %endif
   151                                  
   152                                  
   153                                  
   154                                  
   155                                  
   156                                  
   157                                  
   158                                  
   159                                  
   160                                  
   161                                  
   162                                  section .text
   163                                  ; --------------------------------------------------------
   164                                  ;  CODE SEGMENT @ 0x7e00 (0x7c00 + 0xFF boot sector size)
   165                                  
   166                                  code_segment:
   167                                  
   168                                  
   169                                  ; Interrupt Data
   170                                  PIT_CONTROL_PORT  equ 0x43
   171                                  PIT_CHANNEL_0     equ 0x40
   172                                  IRQ0_VECTOR       equ 0x08
   173                                  
   174                                  ; used for restoring irq0 state -- implementation in 'timer_interrupt.asm'
   175 00000200 0000                    old_irq0_offset dw 0x0000
   176 00000202 0000                    old_irq0_segment dw 0x0000
   177                                  ; PROBLEM WHEN INCLUDING THESE VARIABLES IN TEXT SEGMENT!
   178                                  ; Uncommenting the blow definition will be interpereted as an instruction rather than data, blocking the vm!
   179                                  ; old_irq0_segment dw 0x8bfa 
   180                                  
   181                                  ; timing interrupt counter
   182 00000204 0000                    tick_count dw 0
   183                                  
   184                                  
   185                                  
   186                                  
   187                                  ; Set up video mode (320x200, 256 colors)
   188 00000206 B81300                  mov ax, 0x13
   189 00000209 CD10                    int 0x10
   190                                  
   191                                  ; Set up keyboard interrupt handler
   192 0000020B FA                      cli
   193 0000020C C7062400[610D]          mov word [0x24], keyboard_handler
   194 00000212 C70626000000            mov word [0x26], 0
   195 00000218 FB                      sti
   196                                  
   197                                  ; mov ax, old_irq0_offset
   198                                  ; mov bx, ds
   199                                  ; mov ax, word [bx]
   200                                  
   201                                  
   202                                  ; Figure out location of word_array, as it is NOT in this location when going through disassembled code
   203                                  ; -->  00000219:  A30086  mov [0x8600],ax
   204                                  ; Turns out that all '.code' sections will be concatenated to the assembled .text sections, and the IP will not run the instructions placed in the .code!
   205                                  ; 
   206 00000219 A3[0000]                mov word [word_array], ax
   207                                  
   208                                  section .data
   209                                  
   210                                  
   211                                  ; ; NEEDED TO DEFINE THE ARRAY HERE WITHOUT A SECTION-LABEL TO BE ABLE TO USE THE ARRAY!
   212 00000000 0A0014001E00280032-     word_array: dw 10, 20, 30, 40, 50 ; An array of 5 bytes
   212 00000009 00                 
   213                                  ; ; word_buffer: resw 5 ; 10 bytes without specifying initial value
   214                                  
   215                                  ; byte_array: times 10 db 0 ; 10 bytes initaliezed to '0'
   216                                  ; byte_array_size: equ 10
   217                                  
   218                                  ; frame_buff: times 64 db 0 ; Cant use the 64k that I want for a full framebuffer..
   219                                  ; ; frame_buff_size: equ 640
   220                                  
   221                                  ; framebuffer_64k: 0x7E00
   222                                  ; Initialize buffer location
   223 0000000A B8007E                      mov ax, 0x7E00     ; Address right after boot sector
   224 0000000D 8EC0                        mov es, ax         ; Set extra segment
   225 0000000F 31FF                        xor di, di         ; Zero offset
   226 00000011 B91027                      mov cx, 10000        ; Number of bytes to clear
   227 00000014 30C0                        xor al, al         ; Value to fill (zero)
   228 00000016 F3AA                        rep stosb          ; Clear the buffer
   229                                  
   230                                  
   231                                  
   232                                  ; PIXEL COORIDINATES
   233 00000018 0000                    pixel_x dw 0
   234 0000001A 0000                    pixel_y dw 0
   235                                  
   236                                  
   237                                  ; player location
   238 0000001C 0000                    x dw 0
   239 0000001E 0000                    y dw 0
   240 00000020 C706[1E00]0000          mov WORD [y], 0
   241 00000026 C706[1C00]0000          mov WORD [x], 0
   242                                  
   243                                  ; player position : NOTE: INTIAL VALUE WILL ALWAYS BE 0 WHEN DEFINED IN .data!
   244 0000002C A000                    player_position_x dw 0xA0
   245 0000002E 6000                    player_position_y dw 0x60
   246                                  ; mov word [player_position_x], 0xA0
   247                                  ; mov word [player_position_y], 0x60
   248                                  
   249 00000030 E8(F602)                call render
   250 00000033 E8(F602)                call render
   251 00000036 E8(F602)                call render
   252 00000039 E8(F602)                call render
   253 0000003C E8(F602)                call render
   254                                  
   255                                  
   256                                  section .text
   257                                  
   258                                  
   259                                  ; ; player position
   260                                  ; player_position_x dw 0xA0
   261                                  ; player_position_y dw 0x60
   262                                  
   263                                  timer_setup:
   264                                   ; timer interrupt
   265 0000021C FA                          cli
   266                                  
   267                                      ; Set up PIT for periodic interrupts
   268 0000021D B036                        mov al, 0x36                ; Control word: Mode 3, Square wave generator
   269 0000021F E643                        out PIT_CONTROL_PORT, al
   270                                      ; mov ax, 1193180        ; Set frequency to 100 Hz (adjust as needed)
   271                                  
   272                                      ; minimum : https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interval_Timer
   273 00000221 B8FFFF                      mov ax, 65535 ; ( ~= 1193180 / 18.2)
   274                                      ; mov ax, 39773 ; ( ~= 1193180 / 30 )
   275 00000224 E640                        out PIT_CHANNEL_0, al       ; Low byte
   276 00000226 88E0                        mov al, ah
   277 00000228 E640                        out PIT_CHANNEL_0, al       ; High byte
   278                                  
   279                                  
   280                                      ; Set up custom IRQ0 handler
   281                                      ; Save old handler address
   282 0000022A B80000                      mov ax, 0x0000
   283 0000022D 8EC0                        mov es, ax                  ; ES points to interrupt vector table
   284 0000022F BF2000                      mov di, IRQ0_VECTOR * 4
   285                                      ; backup already existing values in table
   286 00000232 268B05                      mov ax, [es:di]        ; Load offset into AX
   287 00000235 A3[0002]                    mov [old_irq0_offset], ax
   288 00000238 268B4502                    mov ax, [es:di+2]      ; Load segment into AX
   289 0000023C A3[0202]                    mov [old_irq0_segment], ax
   290                                  
   291                                      ; Set new handler
   292                                      ; cli
   293 0000023F 26C705[4C02]                mov word [es:di], timer_handler   ; Offset of custom handler
   294 00000244 268C4D02                    mov word [es:di+2], cs      ; Segment of this code
   295 00000248 FB                          sti                         ; Re-enable interrupts
   296                                  timer_setup_end:
   297                                  
   298                                  
   299                                  
   300                                  
   301                                  ; Main loop
   302                                  ; Stack is untouched at this point
   303                                  main_loop:
   304 00000249 F4                          hlt
   305 0000024A EBFD                        jmp main_loop
   306                                  
   307                                  
   308                                  
   309                                  
   310                                  
   311                                  timer_handler:
   312 0000024C 60                          pusha
   313 0000024D FF06[0402]                  inc word [tick_count]
   314                                  
   315 00000251 89E5                        mov bp, sp ; bp already pushed duing hanlder entry
   316                                  
   317 00000253 E8A000                      call render
   318                                  
   319 00000256 E80600                      call update
   320                                  
   321                                  
   322                                      ; PROBLEM: LOCKS IN BOOT SECTOR AND BLASTS CPU USAGE!
   323                                      ; Render white pixel
   324                                      ; mov ax, 0xA000         ; Segment for video memory
   325                                      ; mov es, ax             ; Point ES to video memory
   326                                      ; mov di, [tick_count] ; Offset for pixel at (100, 50)
   327                                      ; ; mov di, 50 * 320 + 100 ; Offset for pixel at (100, 50)
   328                                      ; mov al, 0x0F           ; Pixel color (bright white)
   329                                      ; mov [es:di], al        ; Write pixel color to video memory
   330                                  
   331                                      ; cmp WORD [w_pressed], 1
   332                                      ; je .w_not_pressed
   333                                      ; ; mov ah, 0x0C  ; BIOS video function: write pixel
   334                                      ; ; mov al, 0x01  ; color -- Blue 
   335                                      ; xor cx, cx
   336                                      ; xor dx, dx
   337                                      ; ; mov cx, 60
   338                                      ; ; mov dx, 60
   339                                  
   340                                      ; ; int 0x10
   341                                      ; .w_not_pressed:
   342                                  
   343                                  
   344                                      ; make sure this label is reachable
   345                                      ; Renders a pixel at [tick_count]
   346                                      ; call reachable
   347                                      ; call extern_pixels
   348                                      ; call write_oooo
   349                                  
   350                                      
   351                                  
   352                                      ; EOI command making sure proper end of interrupt?
   353 00000259 B020                        mov al, 0x20                ; EOI command
   354 0000025B E620                        out 0x20, al                ; Send to PIC command port (0x20)
   355                                  
   356                                      ; End of handler
   357 0000025D 61                          popa                       ; Restore all registers
   358 0000025E CF                          iret                      ; Return from interrupt
   359                                  
   360                                  
   361                                  
   362                                  
   363                                  
   364                                  
   365                                  
   366                                  
   367                                  
   368                                  update:
   369 0000025F E80400                      call .update_player_position
   370 00000262 E83200                      call .update_location
   371 00000265 C3                          ret
   372                                  
   373                                  
   374                                  .update_player_position:
   375 00000266 833E[4700]01            .w: cmp word [w_pressed], 1
   376 0000026B 7505                        jne .a
   377 0000026D 832E[2E00]02                sub word [player_position_y], 2
   378                                      
   379 00000272 833E[4F00]01            .a: cmp word [a_pressed], 1
   380 00000277 7505                        jne .s
   381 00000279 832E[2C00]02                sub word [player_position_x], 2
   382                                  
   383 0000027E 833E[5100]01            .s: cmp word [s_pressed], 1
   384 00000283 7505                        jne .d
   385 00000285 8306[2E00]02                add word [player_position_y], 2
   386                                  
   387 0000028A 833E[5300]01            .d: cmp word [d_pressed], 1
   388 0000028F 7505                        jne .update_player_position_end
   389 00000291 8306[2C00]02                add word [player_position_x], 2
   390                                  .update_player_position_end:
   391                                  
   392 00000296 C3                          ret
   393                                  
   394                                  
   395                                  ; Update current pixel position
   396                                  .update_location:
   397 00000297 FF06[1800]                  inc word [pixel_x]
   398 0000029B 813E[1800]4001              cmp word [pixel_x], 320
   399 000002A1 C3                          ret
   400 000002A2 C706[1800]0000              mov word [pixel_x], 0
   401 000002A8 FF06[1A00]                  inc word [pixel_y]
   402 000002AC 813E[1A00]C800              cmp word [pixel_y], 200
   403 000002B2 C3                          ret 
   404 000002B3 C706[1A00]0000              mov word [pixel_y], 0
   405                                      ; ret
   406                                  .update_location_end:
   407 000002B9 C3                          ret
   408                                  
   409                                  
   410                                  
   411                                  
   412                                  reachable:
   413 000002BA 60                          pusha
   414 000002BB B40C                        mov ah, 0x0C  ; BIOS video function: write pixel
   415 000002BD B00F                        mov al, 0x0F  ; White color
   416 000002BF 8B0E[0402]                  mov cx, [tick_count]
   417 000002C3 BA1400                      mov dx, 20
   418 000002C6 CD10                        int 0x10
   419 000002C8 61                          popa
   420 000002C9 C3                          ret
   421                                  
   422                                  
   423                                  float_test:
   424                                  
   425 000002CA 9BDBE3                      finit
   426                                  
   427                                      ; Load into FPU stack
   428                                      ; top of stack == ST(0)
   429 000002CD D906[7B01]                  fld dword [float_1]    ; ST(0) = float_1
   430 000002D1 D906[7F01]                  fld dword [float_2]    ; ST(0) = float_2, ST(1) = float_1
   431 000002D5 D906[8301]                  fld dword [float_3]    ; ST(0) = float_3, ST(1) = float_2, ST(2) = float_1
   432                                  
   433                                      ; what happens if stack is filled?
   434 000002D9 DF06[6101]                  fild word [tri_2d_int_array]
   435                                  
   436                                  
   437                                      ; fxch ; Swaps spot 0 and 1 ??
   438                                  
   439                                      ; operations
   440                                      ; fadd                  ; ST(0) = ST(0) + ST(1)
   441                                      ; fadd ST(1)     ; ST(0) = ST(0) + ST(1)
   442                                      ; fadd
   443 000002DD DEC9                        fmul                  ; ST(1) = ST(0) * ST(1)
   444                                      ; fdiv                    ; ST(1) = ST(0) / ST(1)
   445                                  
   446                                      ; ; pop the FPU stack into memory
   447                                      ; fstp dword [float_res]
   448                                      
   449                                  
   450                                      ; ; push/load from memory onto FPU stack
   451                                      ; fld dword [float_res]   ; Load 'result' back into ST(0)
   452                                  
   453                                      ; Convert to integer and store in 'integer_result'
   454 000002DF DF1E[8B01]                  fistp word [integer_res] ; Convert and pop ST(0)
   455                                  
   456                                      ; Clear stack?
   457                                      ; Realistically does nothing..
   458 000002E3 DDD9                        fstp
   459 000002E5 DDD9                        fstp
   460                                  
   461                                      ; Draw pixel
   462 000002E7 B80070                      mov ax, VIDEO_D_BUFFER
   463 000002EA 8EC0                        mov es, ax
   464 000002EC 8B3E[8B01]                  mov di, word [integer_res]
   465 000002F0 26C7050F0F                  mov word [es:di], 0x0F0F
   466 000002F5 C3                          ret
   467                                  
   468                                  
   469                                  ; C-like includes
   470                                  %include "./draw/render.asm"
     1                              <1> ; Double buffering segment
     2                              <1> VIDEO_D_BUFFER equ 0x7000
     3                              <1> 
     4                              <1> section   .text
     5                              <1> 
     6                              <1> render:
     7 000002F6 55                  <1>     push bp
     8 000002F7 89E5                <1>     mov bp, sp
     9                              <1>     
    10                              <1>     ; pusha
    11 000002F9 E8B409              <1>     call clear
    12                              <1>     ; call clear_screen_old
    13                              <1> 
    14 000002FC E8D603              <1>     call draw_triangle
    15                              <1>     ; cli 
    16                              <1> 
    17                              <1>     ; hlt
    18                              <1> 
    19 000002FF E8B908              <1>     call draw_wasd_input
    20                              <1> 
    21                              <1>     ; call draw_tests
    22                              <1>     ; call draw_large_square
    23                              <1>     ; call mode_13h_pixel_draw
    24 00000302 E87D09              <1>     call draw_input_incrementing_pixel
    25                              <1>     ; call draw_keycode_coords ; uses interrupts 
    26 00000305 E83F0A              <1>     call extern_pixels
    27 00000308 E89809              <1>     call simple_pixel
    28                              <1> 
    29                              <1>     ; draw player position
    30 0000030B E87405              <1>     call draw_player_position
    31                              <1>     
    32                              <1> 
    33 0000030E E84005              <1>     call a2x2_cluster
    34                              <1> 
    35                              <1> 
    36                              <1>     ; print current cursor buffer
    37 00000311 E84907              <1>     call write_whole_cursor_buffer
    38                              <1>     
    39                              <1> 
    40                              <1>     ; Print once when new ascii press detected
    41 00000314 E82605              <1>     call show_current_ascii_press
    42                              <1> 
    43                              <1> 
    44 00000317 E80606              <1>     call print_available_chars
    45                              <1> 
    46                              <1>     ; mov ax, 0x1234
    47                              <1>     ; mov ax, 0xfa74
    48                              <1>     ; call print_hex_value
    49                              <1> 
    50 0000031A E80303              <1>     call draw_sine
    51                              <1> 
    52                              <1>     ; call draw_current_triangle
    53                              <1> 
    54                              <1> 
    55                              <1>     ; Triangle 1
    56 0000031D E81300              <1>     call update_triangle_velocity
    57 00000320 E81F00              <1>     call update_triangle_position
    58                              <1> 
    59 00000323 E83202              <1>     call transform_triangle_1_into_current
    60 00000326 E8A202              <1>     call current_triangle_into_pixel_coord
    61                              <1>     ; call draw_current_triangle_points
    62 00000329 E8F200              <1>     call draw_current_triangle
    63                              <1> 
    64                              <1> 
    65                              <1> 
    66 0000032C E84503              <1>     call swap_buffer
    67                              <1> 
    68 0000032F 89EC                <1>     mov sp, bp  ; return stack pointer
    69 00000331 5D                  <1>     pop bp      ; restore bp to callers value
    70                              <1>     ; popa
    71 00000332 C3                  <1>     ret
    72                              <1> 
    73                              <1> 
    74                              <1> update_triangle_velocity:
    75 00000333 D906[8D01]          <1>     fld dword [position+0] ; p_x 
    76 00000337 D906[9901]          <1>     fld dword [velocity+0] ; v_x 
    77 0000033B DEC1                <1>     faddp
    78 0000033D D91E[8D01]          <1>     fstp dword [position+0]
    79 00000341 C3                  <1>     ret
    80                              <1> update_triangle_velocity_end:
    81                              <1> 
    82                              <1> 
    83                              <1> update_triangle_position:
    84 00000342 D906[8D01]          <1>     fld dword [position+0] ; p_x 
    85 00000346 D906[9901]          <1>     fld dword [velocity+0] ; v_x 
    86 0000034A DEC1                <1>     faddp
    87 0000034C D91E[8D01]          <1>     fstp dword [position+0]
    88 00000350 C3                  <1>     ret
    89                              <1> update_triangle_position_end:
    90                              <1> 
    91                              <1> ;-- set_current_triangle_loop_span  ---
    92                              <1> ;
    93                              <1> ;   Set the x/y bounding box mins and maxs for current triangle.
    94                              <1> ;   
    95                              <1> set_current_triangle_loop_span:
    96 00000351 C706[F101]4001      <1>     mov word [p_x_int_min], 320
    97 00000357 C706[F301]0000      <1>     mov word [p_x_int_max], 0
    98 0000035D C706[F501]C800      <1>     mov word [p_y_int_min], 200
    99 00000363 C706[F701]0000      <1>     mov word [p_y_int_max], 0
   100                              <1> 
   101                              <1> .p0_x_min:
   102 00000369 A1[F101]            <1>     mov ax, word [p_x_int_min]
   103 0000036C 3906[E101]          <1>     cmp word [p0_x_int], ax
   104 00000370 7306                <1>     jae .p1_x_min ; mov if not below
   105 00000372 A1[E101]            <1>     mov ax, word [p0_x_int]
   106 00000375 A3[F101]            <1>     mov word [p_x_int_min], ax
   107                              <1> 
   108                              <1> .p1_x_min:
   109 00000378 A1[F101]            <1>     mov ax, word [p_x_int_min]
   110 0000037B 3906[E501]          <1>     cmp word [p1_x_int], ax
   111 0000037F 7306                <1>     jae .p2_x_min ; mov if not below
   112 00000381 A1[E501]            <1>     mov ax, word [p1_x_int]
   113 00000384 A3[F101]            <1>     mov word [p_x_int_min], ax
   114                              <1> 
   115                              <1> .p2_x_min:
   116 00000387 A1[F101]            <1>     mov ax, word [p_x_int_min]
   117 0000038A 3906[E901]          <1>     cmp word [p2_x_int], ax
   118 0000038E 7306                <1>     jae .x_min_done ; mov if not below
   119 00000390 A1[E901]            <1>     mov ax, word [p2_x_int]
   120 00000393 A3[F101]            <1>     mov word [p_x_int_min], ax
   121                              <1> .x_min_done: 
   122                              <1> 
   123                              <1> 
   124                              <1> .p0_x_max:
   125 00000396 A1[F301]            <1>     mov ax, word [p_x_int_max]
   126 00000399 3906[E101]          <1>     cmp word [p0_x_int], ax
   127 0000039D 7606                <1>     jbe .p1_x_max ; new max if above current
   128 0000039F A1[E101]            <1>     mov ax, word [p0_x_int]
   129 000003A2 A3[F301]            <1>     mov word [p_x_int_max], ax
   130                              <1> 
   131                              <1> .p1_x_max:
   132 000003A5 A1[F301]            <1>     mov ax, word [p_x_int_max]
   133 000003A8 3906[E501]          <1>     cmp word [p1_x_int], ax
   134 000003AC 7606                <1>     jbe .p2_x_max ; new max if above current
   135 000003AE A1[E501]            <1>     mov ax, word [p1_x_int]
   136 000003B1 A3[F301]            <1>     mov word [p_x_int_max], ax
   137                              <1> 
   138                              <1> .p2_x_max
   138          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+label-orphan]
   139 000003B4 A1[F301]            <1>     mov ax, word [p_x_int_max]
   140 000003B7 3906[E901]          <1>     cmp word [p2_x_int], ax
   141 000003BB 7606                <1>     jbe .x_max_done ; new max if above current
   142 000003BD A1[E901]            <1>     mov ax, word [p2_x_int]
   143 000003C0 A3[F301]            <1>     mov word [p_x_int_max], ax
   144                              <1> .x_max_done: 
   145                              <1> 
   146                              <1> 
   147                              <1> .p0_y_min:
   148 000003C3 A1[F501]            <1>     mov ax, word [p_y_int_min]
   149 000003C6 3906[E301]          <1>     cmp word [p0_y_int], ax
   150 000003CA 7306                <1>     jae .p1_y_min ; new min if below current
   151 000003CC A1[E301]            <1>     mov ax, word [p0_y_int]
   152 000003CF A3[F501]            <1>     mov word [p_y_int_min], ax
   153                              <1> 
   154                              <1> .p1_y_min:
   155 000003D2 A1[F501]            <1>     mov ax, word [p_y_int_min]
   156 000003D5 3906[E501]          <1>     cmp word [p1_x_int], ax
   157 000003D9 7306                <1>     jae .p2_y_min ; new min if below current
   158 000003DB A1[E501]            <1>     mov ax, word [p1_x_int]
   159 000003DE A3[F501]            <1>     mov word [p_y_int_min], ax
   160                              <1> 
   161                              <1> .p2_y_min
   161          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+label-orphan]
   162 000003E1 A1[F501]            <1>     mov ax, word [p_y_int_min]
   163 000003E4 3906[E901]          <1>     cmp word [p2_x_int], ax
   164 000003E8 7306                <1>     jae .y_min_done ; new min if below current
   165 000003EA A1[E901]            <1>     mov ax, word [p2_x_int]
   166 000003ED A3[F501]            <1>     mov word [p_y_int_min], ax
   167                              <1> .y_min_done: 
   168                              <1> 
   169                              <1> 
   170                              <1> .p0_y_max:
   171 000003F0 A1[F701]            <1>     mov ax, word [p_y_int_max]
   172 000003F3 3906[E301]          <1>     cmp word [p0_y_int], ax
   173 000003F7 7606                <1>     jbe .p1_y_max ; new max if above current
   174 000003F9 A1[E301]            <1>     mov ax, word [p0_y_int]
   175 000003FC A3[F701]            <1>     mov word [p_y_int_max], ax
   176                              <1> 
   177                              <1> .p1_y_max:
   178 000003FF A1[F701]            <1>     mov ax, word [p_y_int_max]
   179 00000402 3906[E701]          <1>     cmp word [p1_y_int], ax
   180 00000406 7606                <1>     jbe .p2_y_max ; new max if above current
   181 00000408 A1[E701]            <1>     mov ax, word [p1_y_int]
   182 0000040B A3[F701]            <1>     mov word [p_y_int_max], ax
   183                              <1> 
   184                              <1> .p2_y_max
   184          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+label-orphan]
   185 0000040E A1[F701]            <1>     mov ax, word [p_y_int_max]
   186 00000411 3906[EB01]          <1>     cmp word [p2_y_int], ax
   187 00000415 7606                <1>     jbe .y_max_done ; new max if above current
   188 00000417 A1[EB01]            <1>     mov ax, word [p2_y_int]
   189 0000041A A3[F701]            <1>     mov word [p_y_int_max], ax
   190                              <1> .y_max_done: 
   191                              <1> 
   192                              <1> 
   193 0000041D C3                  <1>     ret
   194                              <1> set_current_triangle_loop_span_end:
   195                              <1> 
   196                              <1> 
   197                              <1> ; ---   draw_current_triangle ------
   198                              <1> ;
   199                              <1> ;   1. sets triangle bounding box values (p_x_int_min, p_x_int_max, p_y_int_min, p_y_int_max)
   200                              <1> ;   2. loops through bounding box integer values
   201                              <1> ;   3. sets all three current triangle signed areas
   202                              <1> ;       4. draw pixel IFF all signed areas are positive (the front of triangle defined using right hand rule)
   203                              <1> ;
   204                              <1> draw_current_triangle:
   205 0000041E 55                  <1>     push bp
   206 0000041F 89E5                <1>     mov bp, sp
   207                              <1> 
   208 00000421 E82DFF              <1>     call set_current_triangle_loop_span
   209                              <1> 
   210                              <1>     ; Loop through pixel row 150
   211 00000424 A1[F101]            <1>     mov ax, word [p_x_int_min]
   212 00000427 A3[ED01]            <1>     mov word [p_x_int], ax   ; start col
   213                              <1> 
   214 0000042A A1[F501]            <1>     mov ax, word [p_y_int_min]
   215 0000042D A3[EF01]            <1>     mov word [p_y_int], ax ; start row
   216                              <1> 
   217 00000430 A1[F701]            <1>     mov ax, word [p_y_int_max]
   218 00000433 89C1                <1>     mov cx, ax ; last row
   219                              <1>     .next_row:
   220                              <1>     
   221 00000435 A1[F101]            <1>     mov ax, word [p_x_int_min]
   222 00000438 A3[ED01]            <1>     mov word [p_x_int], ax   ; reset col to lowest x value of current triangle
   223                              <1> 
   224 0000043B 8B16[F301]          <1>     mov dx, word [p_x_int_max] ; last col
   225                              <1>     .next_col:
   226                              <1> 
   227                              <1>     ; Update the float values to current integer indexes
   228 0000043F DF06[ED01]          <1>     fild word [p_x_int]
   229 00000443 D91E[F901]          <1>     fstp dword [p_x]
   230 00000447 DF06[EF01]          <1>     fild word [p_y_int]
   231 0000044B D91E[FD01]          <1>     fstp dword [p_y]
   232                              <1> 
   233                              <1>     ; check if we should draw
   234                              <1>     ; if all are POSITIVE, draw pixel!
   235 0000044F E83700              <1>     call calc_signed_area_0
   236 00000452 83F801              <1>     cmp ax, 1
   237 00000455 751A                <1>     jne .end_draw
   238 00000457 E87400              <1>     call calc_signed_area_1
   239 0000045A 83F801              <1>     cmp ax, 1
   240 0000045D 7512                <1>     jne .end_draw
   241 0000045F E8B100              <1>     call calc_signed_area_2
   242 00000462 83F801              <1>     cmp ax, 1
   243 00000465 750A                <1>     jne .end_draw
   244                              <1>     
   245                              <1> 
   246 00000467 8B1E[EF01]          <1>     mov bx, word [p_y_int]
   247 0000046B A1[ED01]            <1>     mov ax, word [p_x_int]
   248 0000046E E86903              <1>     call pixel_xa_yb
   249                              <1> 
   250                              <1>     .end_draw:
   251                              <1> 
   252 00000471 FF06[ED01]          <1>     inc word [p_x_int]
   253 00000475 3916[ED01]          <1>     cmp word [p_x_int], dx
   254 00000479 72C4                <1>     jb .next_col
   255                              <1> 
   256 0000047B FF06[EF01]          <1>     inc word [p_y_int]
   257 0000047F 390E[EF01]          <1>     cmp word [p_y_int], cx
   258 00000483 72B0                <1>     jb .next_row
   259                              <1> 
   260 00000485 89EC                <1>     mov sp, bp
   261 00000487 5D                  <1>     pop bp
   262 00000488 C3                  <1>     ret
   263                              <1> draw_current_triangle_end:
   264                              <1> 
   265                              <1> 
   266                              <1> 
   267                              <1> 
   268                              <1> ;---- calc_signed_area_a to calc_signed_area_c -------
   269                              <1> ;
   270                              <1> ;   variables used: [fixed memory locations]
   271                              <1> ;       p_x, pa_x, pb_x
   272                              <1> ;       area_sign_int_a, area_sign_a
   273                              <1> ;
   274                              <1> ;   returns : ax = 1 if sign is positive
   275                              <1> ;
   276                              <1> ;   https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
   277                              <1> ;   
   278                              <1> ;   compare current point 'p' with line from p_a to p_b
   279                              <1> ;   (p_x - pb_x) * (pa_y - pb_y) - (pa_x - pb_x) * (p_y - pb_y)
   280                              <1> ;   = T1 - T2
   281                              <1> ; 
   282                              <1> ;   POSTFIX: 
   283                              <1> ;       T1 = p_x pb_x - pa_y pb_y - *
   284                              <1> ;       T2 = pa_x pb_x - p_y pb_y - *
   285                              <1> ;       
   286                              <1> ;       T1 - T2 = p_x pb_x - pa_y pb_y - * pa_x pb_x - p_y pb_y - * -
   287                              <1> ;
   288                              <1> calc_signed_area_0:
   289                              <1> 
   290 00000489 D906[F901]          <1>     fld dword [p_x]
   291 0000048D D906[D101]          <1>     fld dword [p1_x]
   292 00000491 DEE9                <1>     fsubp
   293 00000493 D906[CD01]          <1>     fld dword [p0_y]
   294 00000497 D906[D501]          <1>     fld dword [p1_y]
   295 0000049B DEE9                <1>     fsubp
   296 0000049D DEC9                <1>     fmulp
   297                              <1> 
   298 0000049F D906[C901]          <1>     fld dword [p0_x]
   299 000004A3 D906[D101]          <1>     fld dword [p1_x]
   300 000004A7 DEE9                <1>     fsubp
   301 000004A9 D906[FD01]          <1>     fld dword [p_y]
   302 000004AD D906[D501]          <1>     fld dword [p1_y]
   303 000004B1 DEE9                <1>     fsubp
   304 000004B3 DEC9                <1>     fmulp
   305                              <1> 
   306 000004B5 DEE9                <1>     fsubp
   307                              <1> 
   308                              <1>     
   309 000004B7 DF16[0502]          <1>     fist word [area_sign_int_0]
   310 000004BB D91E[0102]          <1>     fstp dword [area_sign_0]
   311                              <1> 
   312 000004BF 833E[0502]00        <1>     cmp word [area_sign_int_0], 0
   313 000004C4 7C04                <1>     jl .negative
   314 000004C6 B80100              <1>     mov ax, 1
   315 000004C9 C3                  <1>     ret
   316                              <1>     .negative:
   317 000004CA B80000              <1>     mov ax, 0
   318 000004CD C3                  <1>     ret
   319                              <1> calc_signed_area_0_end:
   320                              <1> calc_signed_area_1:
   321                              <1> 
   322 000004CE D906[F901]          <1>     fld dword [p_x]
   323 000004D2 D906[D901]          <1>     fld dword [p2_x]
   324 000004D6 DEE9                <1>     fsubp
   325 000004D8 D906[D501]          <1>     fld dword [p1_y]
   326 000004DC D906[DD01]          <1>     fld dword [p2_y]
   327 000004E0 DEE9                <1>     fsubp
   328 000004E2 DEC9                <1>     fmulp
   329                              <1> 
   330 000004E4 D906[D101]          <1>     fld dword [p1_x]
   331 000004E8 D906[D901]          <1>     fld dword [p2_x]
   332 000004EC DEE9                <1>     fsubp
   333 000004EE D906[FD01]          <1>     fld dword [p_y]
   334 000004F2 D906[DD01]          <1>     fld dword [p2_y]
   335 000004F6 DEE9                <1>     fsubp
   336 000004F8 DEC9                <1>     fmulp
   337                              <1> 
   338 000004FA DEE9                <1>     fsubp
   339                              <1> 
   340                              <1>     
   341 000004FC DF16[0B02]          <1>     fist word [area_sign_int_1]
   342 00000500 D91E[0702]          <1>     fstp dword [area_sign_1]
   343                              <1> 
   344 00000504 833E[0B02]00        <1>     cmp word [area_sign_int_1], 0
   345 00000509 7C04                <1>     jl .negative
   346 0000050B B80100              <1>     mov ax, 1
   347 0000050E C3                  <1>     ret
   348                              <1>     .negative:
   349 0000050F B80000              <1>     mov ax, 0
   350 00000512 C3                  <1>     ret
   351                              <1> calc_signed_area_1_end:
   352                              <1> calc_signed_area_2:
   353                              <1> 
   354 00000513 D906[F901]          <1>     fld dword [p_x]
   355 00000517 D906[C901]          <1>     fld dword [p0_x]
   356 0000051B DEE9                <1>     fsubp
   357 0000051D D906[DD01]          <1>     fld dword [p2_y]
   358 00000521 D906[CD01]          <1>     fld dword [p0_y]
   359 00000525 DEE9                <1>     fsubp
   360 00000527 DEC9                <1>     fmulp
   361                              <1> 
   362 00000529 D906[D901]          <1>     fld dword [p2_x]
   363 0000052D D906[C901]          <1>     fld dword [p0_x]
   364 00000531 DEE9                <1>     fsubp
   365 00000533 D906[FD01]          <1>     fld dword [p_y]
   366 00000537 D906[CD01]          <1>     fld dword [p0_y]
   367 0000053B DEE9                <1>     fsubp
   368 0000053D DEC9                <1>     fmulp
   369                              <1> 
   370 0000053F DEE9                <1>     fsubp
   371                              <1> 
   372                              <1>     
   373 00000541 DF16[1102]          <1>     fist word [area_sign_int_2]
   374 00000545 D91E[0D02]          <1>     fstp dword [area_sign_2]
   375                              <1> 
   376 00000549 833E[1102]00        <1>     cmp word [area_sign_int_2], 0
   377 0000054E 7C04                <1>     jl .negative
   378 00000550 B80100              <1>     mov ax, 1
   379 00000553 C3                  <1>     ret
   380                              <1>     .negative:
   381 00000554 B80000              <1>     mov ax, 0
   382 00000557 C3                  <1>     ret
   383                              <1> calc_signed_area_2_end:
   384                              <1> 
   385                              <1> 
   386                              <1> 
   387                              <1> ;--- transform_triangle_1_into_current ---------
   388                              <1> ; 
   389                              <1> ;   Applies transformations and move into 'current' points
   390                              <1> ;   
   391                              <1> transform_triangle_1_into_current:
   392 00000558 55                  <1>     push bp
   393 00000559 89E5                <1>     mov bp, sp
   394                              <1> 
   395                              <1>     ; 1. Move triangle_1 points to current triangle
   396                              <1>     ; 2. apply position transformation
   397                              <1>  
   398                              <1>     ; point 0
   399                              <1>     ; x
   400 0000055B D906[1302]          <1>     fld dword [triangle_1+0]
   401 0000055F D906[8D01]          <1>     fld dword [position + 0]
   402 00000563 DEC1                <1>     faddp
   403                              <1>     ; fistp word [current_triangle_pixels+0]
   404                              <1>     ; fstp dword [current_triangle + 0]
   405                              <1>     ; fstp dword [current_triangle + 0]
   406 00000565 DF16[E101]          <1>     fist word [p0_x_int]
   407 00000569 D91E[C901]          <1>     fstp dword [p0_x]
   408                              <1>     ; y
   409 0000056D D906[1702]          <1>     fld dword [triangle_1+4]
   410 00000571 D906[9101]          <1>     fld dword [position + 4]
   411 00000575 DEC1                <1>     faddp
   412                              <1>     ; fistp word [current_triangle_pixels+2]
   413                              <1>     ; fstp dword [current_triangle + 4]
   414 00000577 DF16[E301]          <1>     fist word [p0_y_int]
   415 0000057B D91E[CD01]          <1>     fstp dword [p0_y]
   416                              <1> 
   417                              <1>     ; point 1
   418                              <1> 
   419 0000057F D906[1F02]          <1>     fld dword [triangle_1+12]
   420 00000583 D906[8D01]          <1>     fld dword [position + 0]
   421 00000587 DEC1                <1>     faddp
   422                              <1>     ; fistp word [current_triangle_pixels+4]
   423                              <1>     ; fstp dword [current_triangle + 12]
   424 00000589 DF16[E501]          <1>     fist word [p1_x_int]
   425 0000058D D91E[D101]          <1>     fstp dword [p1_x]
   426                              <1> 
   427 00000591 D906[2302]          <1>     fld dword [triangle_1+16]
   428 00000595 D906[9101]          <1>     fld dword [position + 4]
   429 00000599 DEC1                <1>     faddp
   430                              <1>     ; fistp word [current_triangle_pixels+6]
   431                              <1>     ; fstp dword [current_triangle + 16]
   432 0000059B DF16[E701]          <1>     fist word [p1_y_int]
   433 0000059F D91E[D501]          <1>     fstp dword [p1_y]
   434                              <1> 
   435                              <1>     ; point 2
   436 000005A3 D906[2B02]          <1>     fld dword [triangle_1+24]
   437 000005A7 D906[8D01]          <1>     fld dword [position + 0]
   438 000005AB DEC1                <1>     faddp
   439                              <1>     ; fistp word [current_triangle_pixels+8]
   440                              <1>     ; fstp dword [current_triangle + 24]
   441 000005AD DF16[E901]          <1>     fist word [p2_x_int]
   442 000005B1 D91E[D901]          <1>     fstp dword [p2_x]
   443                              <1> 
   444 000005B5 D906[2F02]          <1>     fld dword [triangle_1+28]
   445 000005B9 D906[9101]          <1>     fld dword [position + 4]
   446 000005BD DEC1                <1>     faddp
   447                              <1>     ; fistp word [current_triangle_pixels+10]
   448                              <1>     ; fstp dword [current_triangle + 28]
   449 000005BF DF16[EB01]          <1>     fist word [p2_y_int]
   450 000005C3 D91E[DD01]          <1>     fstp dword [p2_y]
   451                              <1> 
   452                              <1>     ; call draw_current_triangle_points
   453                              <1> 
   454                              <1> 
   455 000005C7 89EC                <1>     mov sp, bp
   456 000005C9 5D                  <1>     pop bp
   457 000005CA C3                  <1>     ret
   458                              <1> transform_triangle_1_into_current_end:
   459                              <1> 
   460                              <1> 
   461                              <1> 
   462                              <1> current_triangle_into_pixel_coord:
   463 000005CB 55                  <1>     push bp
   464 000005CC 89E5                <1>     mov bp, sp
   465                              <1> 
   466                              <1>     ; 1. Move current triangle points to pixel coordinates
   467                              <1>  
   468                              <1>     ; point 0
   469                              <1>     ; x
   470 000005CE D906[C901]          <1>     fld dword [p0_x]
   471 000005D2 DF1E[A501]          <1>     fistp word [current_triangle_pixels+0]
   472                              <1>     ; y
   473 000005D6 D906[CD01]          <1>     fld dword [p0_y]
   474 000005DA DF1E[A701]          <1>     fistp word [current_triangle_pixels+2]
   475                              <1> 
   476                              <1>     ; point 1
   477                              <1>     ; x
   478 000005DE D906[D101]          <1>     fld dword [p1_x]
   479 000005E2 DF1E[A901]          <1>     fistp word [current_triangle_pixels+4]
   480                              <1>     ; y
   481 000005E6 D906[D501]          <1>     fld dword [p1_y]
   482 000005EA DF1E[AB01]          <1>     fistp word [current_triangle_pixels+6]
   483                              <1> 
   484                              <1>     ; point 2
   485                              <1>     ; x
   486 000005EE D906[D901]          <1>     fld dword [p2_x]
   487 000005F2 DF1E[AD01]          <1>     fistp word [current_triangle_pixels+8]
   488                              <1>     ; y
   489 000005F6 D906[DD01]          <1>     fld dword [p2_y]
   490 000005FA DF1E[AF01]          <1>     fistp word [current_triangle_pixels+10]
   491                              <1> 
   492                              <1>     ; call draw_current_triangle
   493                              <1> 
   494 000005FE 89EC                <1>     mov sp, bp
   495 00000600 5D                  <1>     pop bp
   496 00000601 C3                  <1>     ret
   497                              <1> current_triangle_into_pixel_coord_end:
   498                              <1> 
   499                              <1> 
   500                              <1> 
   501                              <1> draw_current_triangle_points:
   502 00000602 BE[A501]            <1>     mov si, current_triangle_pixels
   503                              <1> 
   504 00000605 8B04                <1>     mov ax, [si+0]
   505 00000607 8B5C02              <1>     mov bx, [si+2]
   506 0000060A E8CD01              <1>     call pixel_xa_yb
   507                              <1> 
   508 0000060D 8B4404              <1>     mov ax, [si+4]
   509 00000610 8B5C06              <1>     mov bx, [si+6]
   510 00000613 E8C401              <1>     call pixel_xa_yb
   511                              <1> 
   512 00000616 8B4408              <1>     mov ax, [si+8]
   513 00000619 8B5C0A              <1>     mov bx, [si+10]
   514 0000061C E8BB01              <1>     call pixel_xa_yb
   515                              <1> 
   516 0000061F C3                  <1>     ret
   517                              <1> draw_current_triangle_points_end:
   518                              <1> 
   519                              <1> 
   520                              <1> 
   521                              <1> 
   522                              <1> ;--- draw_sine ---------
   523                              <1> ; 
   524                              <1> ;   Loops through integers in range [0, SCREEN_WIDTH].
   525                              <1> ;   Maps each x-coord to sine function.
   526                              <1> ;   Will print the y-coord
   527                              <1> draw_sine:
   528 00000620 55                  <1>     push bp
   529 00000621 89E5                <1>     mov bp, sp
   530                              <1> 
   531                              <1>     ; Local vars
   532 00000623 83EC02              <1>     sub sp, 2 ; x = [bp - 2]
   533 00000626 83EC02              <1>     sub sp, 2 ; y = [bp - 4]
   534 00000629 C746FE0000          <1>     mov word [bp - 2], 0
   535                              <1> 
   536 0000062E 83EC02              <1>     sub sp, 2 ; A = [bp - 6]
   537 00000631 83EC02              <1>     sub sp, 2 ; V = [bp - 8]
   538 00000634 83EC02              <1>     sub sp, 2 ; c = [bp - 10]
   539 00000637 C746FA1400          <1>     mov word [bp - 6], 20
   540 0000063C C746F86400          <1>     mov word [bp - 8], 100
   541 00000641 C746F60A00          <1>     mov word [bp - 10], 10
   542                              <1>     
   543                              <1>     ; Loop through all x-coords
   544                              <1>     .next_x:
   545                              <1> 
   546                              <1>     ;-------------------------
   547                              <1>     ;   Sine curve
   548                              <1>     ;   f(x) =  V + A*sin(x/c)
   549                              <1>     ;   RPN:    V A x c / sin * +
   550                              <1>     ;------------------------]
   551 00000646 DF46F8              <1>     fild word [bp - 8]  ; V
   552 00000649 DF46FA              <1>     fild word [bp - 6]  ; A
   553 0000064C DF46FE              <1>     fild word [bp - 2]  ; x
   554 0000064F DF46F6              <1>     fild word [bp - 10] ; c
   555 00000652 DEF9                <1>     fdivp
   556 00000654 D9FE                <1>     fsin
   557 00000656 DEC9                <1>     fmulp
   558 00000658 DEC1                <1>     faddp
   559                              <1> 
   560 0000065A DF5EFC              <1>     fistp word [bp - 4] ; y
   561                              <1>     
   562                              <1>     ; Draw pixel
   563 0000065D 8B46FE              <1>     mov ax, word [bp - 2]
   564 00000660 8B5EFC              <1>     mov bx, word [bp - 4]
   565 00000663 E87401              <1>     call pixel_xa_yb
   566                              <1> 
   567                              <1> 
   568 00000666 FF46FE              <1>     inc word [bp - 2]
   569 00000669 817EFE4001          <1>     cmp word [bp - 2], 320
   570 0000066E 72D6                <1>     jb .next_x
   571                              <1> 
   572 00000670 89EC                <1>     mov sp, bp
   573 00000672 5D                  <1>     pop bp
   574 00000673 C3                  <1>     ret
   575                              <1> draw_sine_end:
   576                              <1>     
   577                              <1> ; First attempt to reduce flickering by swapping
   578                              <1> swap_buffer:
   579                              <1>     ; pusha
   580                              <1> 
   581                              <1>     ; fsqrt
   582                              <1> 
   583                              <1>     ; draw six pixels to second buffer
   584 00000674 B80070              <1>     mov ax, 0x7000
   585 00000677 8EC0                <1>     mov es, ax
   586 00000679 BF8202              <1>     mov di, 642
   587 0000067C 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   588 00000681 BF8402              <1>     mov di, 644
   589 00000684 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   590 00000689 BF8602              <1>     mov di, 646
   591 0000068C 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   592 00000691 BF8802              <1>     mov di, 648
   593 00000694 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   594 00000699 BF8A02              <1>     mov di, 650
   595 0000069C 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   596                              <1> 
   597                              <1>     ; cli
   598 000006A1 1E                  <1>     push ds
   599                              <1> 
   600 000006A2 E82200              <1>     call wait_for_vsync
   601                              <1>     
   602 000006A5 B80070              <1>     mov ax, 0x7000
   603 000006A8 8EC0                <1>     mov es, ax
   604                              <1> 
   605 000006AA B800A0              <1>     mov ax, 0xA000
   606 000006AD 8ED8                <1>     mov ds, ax
   607                              <1> 
   608 000006AF 31FF                <1>     xor di, di
   609 000006B1 31F6                <1>     xor si, si
   610 000006B3 B900FA              <1>     mov cx, 64000
   611 000006B6 BA00FA              <1>     mov dx, 64000
   612                              <1>     ; xor cx, cx
   613                              <1>     ; xor si, si
   614                              <1>     .loop_1:
   615                              <1> 
   616 000006B9 268A04              <1>     mov al, byte [es:si]
   617 000006BC 3E8805              <1>     mov byte [ds:di], al
   618                              <1> 
   619                              <1>     ; rep movsw
   620 000006BF 46                  <1>     inc si
   621 000006C0 47                  <1>     inc di
   622                              <1>     ; sli
   623 000006C1 39D6                <1>     cmp si, dx
   624 000006C3 72F4                <1>     jb .loop_1
   625                              <1>     ; DEBUG
   626                              <1>     ; cli
   627                              <1>     ; hlt
   628                              <1> 
   629 000006C5 1F                  <1>     pop ds
   630                              <1> 
   631                              <1> 
   632                              <1> 
   633                              <1>     ; popa
   634 000006C6 C3                  <1>     ret
   635                              <1> swap_buffer_end:
   636                              <1> 
   637                              <1> ; Attempt to avoid writing to framebuffer during render
   638                              <1> wait_for_vsync:
   639 000006C7 BADA03              <1>     mov dx, 0x03DA     ; VGA input status register
   640                              <1> vsync_start:
   641 000006CA EC                  <1>     in al, dx          ; Read the status
   642 000006CB A808                <1>     test al, 0x08      ; Check vertical retrace bit (bit 3)
   643 000006CD 74FB                <1>     jz vsync_start     ; Wait until retrace starts
   644                              <1> vsync_end:
   645 000006CF EC                  <1>     in al, dx
   646 000006D0 A808                <1>     test al, 0x08
   647 000006D2 75FB                <1>     jnz vsync_end      ; Wait until retrace ends
   648 000006D4 C3                  <1>     ret
   649                              <1> 
   650                              <1> ; Draws a triangle outline based on the 'tri_2d_int_array' array
   651                              <1> ;
   652                              <1> ; No inputs nor outputs; only reading the fixed data array
   653                              <1> draw_triangle:
   654                              <1>     ; pusha
   655 000006D5 55                  <1>     push bp
   656 000006D6 89E5                <1>     mov bp, sp
   657                              <1> 
   658                              <1>     ; P1 : Upper left corner
   659 000006D8 8B1E[6301]          <1>     mov bx, word [tri_2d_int_array+2]    ; y
   660 000006DC A1[6101]            <1>     mov ax, word [tri_2d_int_array+0]    ; x
   661 000006DF E8F800              <1>     call pixel_xa_yb
   662                              <1>     ; add sp, 6
   663                              <1> 
   664                              <1>     ; P2 : top right corner
   665 000006E2 8B1E[6901]          <1>     mov bx, word [tri_2d_int_array+8]    ; y
   666 000006E6 A1[6701]            <1>     mov ax, word [tri_2d_int_array+6]    ; x
   667 000006E9 E8EE00              <1>     call pixel_xa_yb
   668                              <1> 
   669                              <1>     ; P3 : Bottom left corner
   670 000006EC 8B1E[6F01]          <1>     mov bx, word [tri_2d_int_array+14]    ; y
   671 000006F0 A1[6D01]            <1>     mov ax, word [tri_2d_int_array+12]    ; x
   672 000006F3 E8E400              <1>     call pixel_xa_yb
   673                              <1> 
   674                              <1> 
   675                              <1>     ;
   676                              <1>     ; Draw line from point 1 to point 2
   677                              <1>     ;
   678 000006F6 FF36[6901]          <1>     push word [tri_2d_int_array+8] ; y_1
   679 000006FA FF36[6701]          <1>     push word [tri_2d_int_array+6] ; x_1
   680 000006FE FF36[6301]          <1>     push word [tri_2d_int_array+2] ; y_0
   681 00000702 FF36[6101]          <1>     push word [tri_2d_int_array+0] ; x_0
   682 00000706 E87A00              <1>     call draw_line
   683 00000709 83C408              <1>     add sp, 8
   684 0000070C DDC1                <1>     ffree st1
   685                              <1>     ;
   686                              <1>     ; Draw line from point 1 to point 3
   687                              <1>     ;
   688 0000070E FF36[6F01]          <1>     push word [tri_2d_int_array+14] ; y_1
   689 00000712 FF36[6D01]          <1>     push word [tri_2d_int_array+12] ; x_1
   690 00000716 FF36[6301]          <1>     push word [tri_2d_int_array+2] ; y_0
   691 0000071A FF36[6101]          <1>     push word [tri_2d_int_array+0] ; x_0
   692 0000071E E86200              <1>     call draw_line
   693 00000721 83C408              <1>     add sp, 8
   694                              <1> 
   695                              <1>     ;
   696                              <1>     ; Draw line from point 3 to point 2
   697                              <1>     ;
   698                              <1> 
   699                              <1> 
   700                              <1>     ; DELTAS
   701                              <1>     ;
   702                              <1>     ; delta x
   703 00000724 A1[6701]            <1>     mov ax, [tri_2d_int_array+6]
   704 00000727 2B06[6D01]          <1>     sub ax, [tri_2d_int_array+12]
   705                              <1>     ; delta y
   706 0000072B 8B1E[6901]          <1>     mov bx, [tri_2d_int_array+8]
   707 0000072F 2B1E[6F01]          <1>     sub bx, [tri_2d_int_array+14]
   708                              <1> 
   709                              <1>     ; Add delta as constants for the rest of point 3 to point 2
   710 00000733 50                  <1>     push ax
   711 00000734 53                  <1>     push bx
   712                              <1>     
   713                              <1> 
   714                              <1>     ; SLOPE
   715                              <1>     ;
   716 00000735 8B46FE              <1>     mov ax, word [bp - 2]
   717 00000738 8B5EFC              <1>     mov bx, word [bp - 4]
   718 0000073B E8BF00              <1>     call slope_100
   719                              <1>     ; slope returned in dx
   720 0000073E 52                  <1>     push dx ; persist the slope100
   721 0000073F 8B7EFA              <1>     mov di, [bp - 6]
   722                              <1> 
   723                              <1>     ; print slope
   724 00000742 50                  <1>     push ax
   725 00000743 89D0                <1>     mov ax, dx
   726 00000745 E84B01              <1>     call print_hex_value
   727 00000748 58                  <1>     pop ax
   728                              <1>     ; draw points between point 3 and 2
   729                              <1>     ; starting at point 3
   730                              <1> 
   731                              <1>     ; push ax ; delta x
   732                              <1> 
   733 00000749 B90000              <1>     mov cx, 0; x index
   734                              <1>     .line_next_step:
   735 0000074C 41                  <1>     inc cx
   736                              <1>     
   737                              <1>     ; starting values
   738 0000074D A1[6D01]            <1>     mov ax, word [tri_2d_int_array+12] ; x
   739 00000750 8B1E[6F01]          <1>     mov bx, word [tri_2d_int_array+14] ; y
   740                              <1> 
   741                              <1>     ; increment x coord
   742 00000754 01C8                <1>     add ax, cx
   743                              <1> 
   744                              <1>     ; multiply x offset by slope
   745 00000756 51                  <1>     push cx ; [pb - 8] = x offset from origin point
   746 00000757 DF46F8              <1>     fild word [bp - 8]
   747 0000075A DF46FA              <1>     fild word [bp - 6] ; slope100
   748 0000075D DEC9                <1>     fmul
   749 0000075F 83C402              <1>     add sp, 2 ; remove x offset
   750 00000762 6A64                <1>     push word 100 ; [pb - 8] = slope multiplier
   751 00000764 DF46F8              <1>     fild word [bp - 8]
   752 00000767 DEF9                <1>     fdiv
   753 00000769 DF5EF8              <1>     fistp word [bp - 8]
   754 0000076C 8B56F8              <1>     mov dx, word [bp - 8]
   755 0000076F 83C402              <1>     add sp, 2     ; clear slope multiplier
   756                              <1> 
   757                              <1> 
   758                              <1> 
   759 00000772 01D3                <1>     add bx, dx
   760                              <1> 
   761 00000774 E86300              <1>     call pixel_xa_yb
   762                              <1> 
   763 00000777 3B4EFE              <1>     cmp cx, [bp - 2]
   764 0000077A 7ED0                <1>     jle .line_next_step
   765                              <1> 
   766                              <1>     
   767                              <1>     
   768 0000077C 83C406              <1>     add sp, 6
   769                              <1> 
   770                              <1>     
   771                              <1> 
   772 0000077F 89EC                <1>     mov sp, bp
   773 00000781 5D                  <1>     pop bp
   774                              <1>     ; popa
   775 00000782 C3                  <1>     ret
   776                              <1> draw_triangle_end:
   777                              <1> 
   778                              <1> 
   779                              <1> 
   780                              <1> ;   fn: DRAW_LINE
   781                              <1> ;
   782                              <1> ;   y_1 = bp + 10
   783                              <1> ;   x_1 = bp + 8
   784                              <1> ;   y_0 = bp + 6
   785                              <1> ;   x_0 = bp + 4
   786                              <1> ;
   787                              <1> draw_line:
   788 00000783 55                  <1>     push bp
   789 00000784 89E5                <1>     mov bp, sp
   790                              <1> 
   791                              <1>     ; DELTAS
   792                              <1>     ;
   793                              <1>     ; delta x
   794 00000786 8B4608              <1>     mov ax, [bp + 8]
   795 00000789 2B4604              <1>     sub ax, [bp + 4]
   796                              <1>     ; delta y
   797 0000078C 8B5E0A              <1>     mov bx, [bp + 10]
   798 0000078F 2B5E06              <1>     sub bx, [bp + 6]
   799                              <1> 
   800                              <1>     ; Add delta as constants for the rest of point 3 to point 2
   801 00000792 50                  <1>     push ax
   802 00000793 53                  <1>     push bx
   803                              <1>     
   804                              <1> 
   805                              <1>     ; SLOPE
   806                              <1>     ;
   807 00000794 8B46FE              <1>     mov ax, word [bp - 2]
   808 00000797 8B5EFC              <1>     mov bx, word [bp - 4]
   809 0000079A E86000              <1>     call slope_100
   810                              <1>     ; slope returned in dx
   811 0000079D 52                  <1>     push dx ; persist the slope100
   812 0000079E 8B7EFA              <1>     mov di, [bp - 6]
   813                              <1> 
   814                              <1>     ; print slope
   815                              <1>     ; push ax
   816                              <1>     ; mov ax, dx
   817                              <1>     ; call print_hex_value
   818                              <1>     ; pop ax
   819                              <1>     ; draw points between point 3 and 2
   820                              <1>     ; starting at point 3
   821                              <1> 
   822                              <1>     ; push ax ; delta x
   823                              <1> 
   824 000007A1 B90000              <1>     mov cx, 0; x index
   825                              <1>     .line_next_step:
   826 000007A4 41                  <1>     inc cx
   827                              <1>     
   828                              <1>     ; starting values
   829 000007A5 8B4604              <1>     mov ax, word [bp + 4] ; x
   830 000007A8 8B5E06              <1>     mov bx, word [bp + 6] ; y
   831                              <1> 
   832                              <1>     ; increment x coord
   833 000007AB 01C8                <1>     add ax, cx
   834                              <1> 
   835                              <1>     ; multiply x offset by slope
   836 000007AD 51                  <1>     push cx ; [pb - 8] = x offset from origin point
   837 000007AE DF46F8              <1>     fild word [bp - 8]
   838 000007B1 DF46FA              <1>     fild word [bp - 6] ; slope100
   839 000007B4 DEC9                <1>     fmul
   840 000007B6 83C402              <1>     add sp, 2 ; remove x offset
   841 000007B9 6A64                <1>     push word 100 ; [pb - 8] = slope multiplier
   842 000007BB DF46F8              <1>     fild word [bp - 8]
   843 000007BE DEF9                <1>     fdiv
   844 000007C0 DF5EF8              <1>     fistp word [bp - 8]
   845 000007C3 8B56F8              <1>     mov dx, word [bp - 8]
   846 000007C6 83C402              <1>     add sp, 2     ; clear slope multiplier
   847                              <1> 
   848                              <1> 
   849                              <1> 
   850 000007C9 01D3                <1>     add bx, dx
   851                              <1> 
   852 000007CB E80C00              <1>     call pixel_xa_yb
   853                              <1> 
   854 000007CE 3B4EFE              <1>     cmp cx, [bp - 2]
   855 000007D1 7ED1                <1>     jle .line_next_step
   856                              <1> 
   857                              <1>     
   858                              <1>     
   859 000007D3 83C406              <1>     add sp, 6
   860                              <1> 
   861 000007D6 89EC                <1>     mov sp, bp
   862 000007D8 5D                  <1>     pop bp
   863 000007D9 C3                  <1>     ret
   864                              <1> 
   865                              <1> draw_line_end:
   866                              <1> 
   867                              <1> 
   868                              <1> 
   869                              <1> ; fn: PIXEL_XA_YB
   870                              <1> ;
   871                              <1> ; Draws pixel WITHOUT register or stack side effects.
   872                              <1> ; Color: white
   873                              <1> ; Coordinate system: right handed with origin botton left
   874                              <1> ; input:
   875                              <1> ;       ax : x location
   876                              <1> ;       bx : y location
   877                              <1> pixel_xa_yb:
   878 000007DA 51                  <1>     push cx ; x index
   879 000007DB 52                  <1>     push dx ; y index
   880 000007DC 06                  <1>     push es ; video memory segment
   881 000007DD 57                  <1>     push di ; offset
   882                              <1> 
   883 000007DE B90070              <1>     mov cx, VIDEO_D_BUFFER ; cx is a temp leave ax/bx untouched
   884 000007E1 8EC1                <1>     mov es, cx
   885 000007E3 31C9                <1>     xor cx, cx
   886                              <1> 
   887 000007E5 BAC800              <1>     mov dx, 200
   888 000007E8 29DA                <1>     sub dx, bx
   889                              <1> 
   890 000007EA 89C1                <1>     mov cx, ax
   891                              <1> 
   892 000007EC BF4001              <1>     mov di, 320
   893 000007EF 0FAFFA              <1>     imul di, dx
   894 000007F2 01CF                <1>     add di, cx
   895                              <1> 
   896 000007F4 26C6050F            <1>     mov byte [es:di], 0x0F
   897                              <1>     
   898 000007F8 5F                  <1>     pop di
   899 000007F9 07                  <1>     pop es
   900 000007FA 5A                  <1>     pop dx
   901 000007FB 59                  <1>     pop cx
   902 000007FC C3                  <1>     ret
   903                              <1> pixel_xa_yb_end:
   904                              <1> 
   905                              <1> 
   906                              <1> 
   907                              <1> 
   908                              <1> 
   909                              <1> ; fn    :   Returns the slope of the delta x & y.
   910                              <1> ; in    :   ax = delta x
   911                              <1> ;           bx = delta y
   912                              <1> ; ret   :   dx = slope * 100 (dy/dx*100)
   913                              <1> ; modreg:   
   914                              <1> slope_100:
   915 000007FD 55                  <1>     push bp
   916 000007FE 89E5                <1>     mov bp, sp
   917                              <1> 
   918 00000800 50                  <1>     push ax     ; delta x
   919 00000801 53                  <1>     push bx     ; delta y
   920 00000802 6A64                <1>     push word 100
   921 00000804 83EC02              <1>     sub sp, 2   ; slope integer
   922                              <1> 
   923 00000807 DF46FC              <1>     fild word [bp - 4] ; dy = ST 1
   924 0000080A DF46FE              <1>     fild word [bp - 2] ; dx = ST 0
   925                              <1> 
   926 0000080D DEF9                <1>     fdiv  ; ST(0) = ST(1) / ST(0) ?
   927                              <1> 
   928 0000080F DF46FA              <1>     fild word [bp - 6] ; 100 multiplier
   929                              <1> 
   930 00000812 DEC9                <1>     fmul
   931                              <1> 
   932                              <1>     ; fistp dword [slope_float]     ; Convert and pop ST(0)
   933                              <1> 
   934                              <1>     ; pop into memory, then into ax for resturn
   935 00000814 DF5EF8              <1>     fistp word [bp - 8]
   936 00000817 8B56F8              <1>     mov dx, word [bp - 8]   
   937                              <1> 
   938                              <1>     
   939 0000081A 83C402              <1>     add sp, 2 ;reset local variable
   940 0000081D 83C402              <1>     add sp, 2 ;
   941 00000820 5B                  <1>     pop bx ; delta y
   942 00000821 58                  <1>     pop ax ; delta x
   943                              <1> 
   944 00000822 89EC                <1>     mov sp, bp
   945 00000824 5D                  <1>     pop bp
   946 00000825 C3                  <1>     ret
   947                              <1> slope_100_end:
   948                              <1> 
   949                              <1> ; fn    :   Returns the slope of the delta x & y.
   950                              <1> ; in    :   ax = delta x
   951                              <1> ;           bx = delta y
   952                              <1> ; ret   :   si = slope * 100 (dy/dx*100)
   953                              <1> ; modreg:   
   954                              <1> slope_calc_100_old_int:
   955 00000826 51                  <1>     push cx
   956 00000827 52                  <1>     push dx
   957                              <1> 
   958 00000828 BE0000              <1>     mov si, 0x0000
   959 0000082B 89DA                <1>         mov dx, bx
   960 0000082D 6BD264              <1>         imul dx, 100
   961                              <1>         ; count number of dx in dy*100
   962 00000830 B90000              <1>         mov cx, 0
   963                              <1>     .slope_calc_loop:
   964 00000833 01C1                <1>         add cx, ax
   965 00000835 46                  <1>         inc si
   966 00000836 39D1                <1>         cmp cx, dx
   967 00000838 7EF9                <1>         jle .slope_calc_loop
   968                              <1>     .slope_calc_loop_end:
   969                              <1> 
   970 0000083A 5A                  <1>     pop dx
   971 0000083B 59                  <1>     pop cx
   972 0000083C C3                  <1>     ret
   973                              <1> slope_calc_100_old_int_end:
   974                              <1> 
   975                              <1> 
   976                              <1> 
   977                              <1> show_current_ascii_press:
   978 0000083D 833E[5500]00        <1>     cmp word [ascii_current_press], 0
   979 00000842 740C                <1>     je .write_current_press_end
   980 00000844 A1[5500]            <1>     mov ax, word [ascii_current_press]
   981 00000847 E84802              <1>     call write_ascii_char_at_cursor
   982 0000084A C706[5500]0000      <1>     mov word [ascii_current_press], 0 ; reset current press value as it is acting as press-flag
   983                              <1>     .write_current_press_end:
   984 00000850 C3                  <1>     ret
   985                              <1> 
   986                              <1> 
   987                              <1> a2x2_cluster:
   988 00000851 6A00                <1>     push 0x00   ; color
   989 00000853 6A69                <1>     push  105    ; y
   990 00000855 6A69                <1>     push  105    ; x
   991 00000857 E83403              <1>     call draw_2x2
   992 0000085A 83C406              <1>     add sp, 6
   993                              <1> 
   994 0000085D 6A00                <1>     push 0x00   ; color
   995 0000085F 6A67                <1>     push  103    ; y
   996 00000861 6A65                <1>     push  101    ; x
   997 00000863 E82803              <1>     call draw_2x2
   998 00000866 83C406              <1>     add sp, 6
   999                              <1> 
  1000 00000869 6A00                <1>     push 0x00   ; color
  1001 0000086B 6A65                <1>     push  101    ; y
  1002 0000086D 6A68                <1>     push  104    ; x
  1003 0000086F E81C03              <1>     call draw_2x2
  1004 00000872 83C406              <1>     add sp, 6
  1005                              <1> 
  1006 00000875 6A00                <1>     push 0x00   ; color
  1007 00000877 6A64                <1>     push 100    ; y
  1008 00000879 6A64                <1>     push 100    ; x
  1009 0000087B E81003              <1>     call draw_2x2
  1010 0000087E 83C406              <1>     add sp, 6
  1011                              <1> 
  1012 00000881 C3                  <1>     ret
  1013                              <1> 
  1014                              <1> draw_player_position:
  1015 00000882 6A02                <1>     push 0x02   ; color
  1016 00000884 FF36[2E00]          <1>     push word [player_position_y]    ; y
  1017 00000888 FF36[2C00]          <1>     push word [player_position_x]    ; x
  1018 0000088C E8FF02              <1>     call draw_2x2
  1019 0000088F 83C406              <1>     add sp, 6
  1020 00000892 C3                  <1>     ret
  1021                              <1> 
  1022                              <1> 
  1023                              <1> ; fn: prints the 16-bit value as hex number in screen low right corner
  1024                              <1> ; in: ax = word-width value to print
  1025                              <1> print_hex_value:
  1026 00000893 55                  <1>     push bp
  1027 00000894 89E5                <1>     mov bp, sp
  1028                              <1> 
  1029                              <1>     ; Store the original value to be printed
  1030 00000896 50                  <1>     push ax
  1031                              <1> 
  1032                              <1> 
  1033                              <1>     ; word_l, low nibble
  1034 00000897 8B76FE              <1>     mov si, [bp - 2]
  1035 0000089A C1E60C              <1>     shl si, 12
  1036 0000089D C1EE0C              <1>     shr si, 12
  1037 000008A0 8A9C[3702]          <1>     mov bl, byte [hex_print_table + si]
  1038 000008A4 30FF                <1>     xor bh, bh
  1039                              <1> 
  1040 000008A6 89D8                <1>     mov ax, bx
  1041 000008A8 E80602              <1>     call char_ascii_to_bitmap_address
  1042 000008AB 50                  <1>     push ax             ; char address
  1043 000008AC 68BE00              <1>     push 190            ; y
  1044 000008AF 683601              <1>     push 310             ; x
  1045 000008B2 E8A502              <1>     call write_char_from_bitmap_address
  1046 000008B5 83C406              <1>     add sp, 6
  1047                              <1> 
  1048                              <1> 
  1049                              <1>     ; word_l, high nibble
  1050 000008B8 8B76FE              <1>     mov si, [bp - 2]
  1051 000008BB C1E608              <1>     shl si, 8
  1052 000008BE C1EE0C              <1>     shr si, 12
  1053 000008C1 8A9C[3702]          <1>     mov bl, byte [hex_print_table + si]
  1054 000008C5 30FF                <1>     xor bh, bh
  1055                              <1> 
  1056 000008C7 89D8                <1>     mov ax, bx
  1057 000008C9 E8E501              <1>     call char_ascii_to_bitmap_address
  1058 000008CC 50                  <1>     push ax             ; char address
  1059 000008CD 68BE00              <1>     push 190            ; y
  1060 000008D0 682C01              <1>     push 300             ; x
  1061 000008D3 E88402              <1>     call write_char_from_bitmap_address
  1062 000008D6 83C406              <1>     add sp, 6
  1063                              <1> 
  1064                              <1>     ; word_h, low nibble
  1065 000008D9 8B76FE              <1>     mov si, [bp - 2]
  1066 000008DC C1E604              <1>     shl si, 4
  1067 000008DF C1EE0C              <1>     shr si, 12
  1068 000008E2 8A9C[3702]          <1>     mov bl, byte [hex_print_table + si]
  1069 000008E6 30FF                <1>     xor bh, bh
  1070                              <1> 
  1071 000008E8 89D8                <1>     mov ax, bx
  1072 000008EA E8C401              <1>     call char_ascii_to_bitmap_address
  1073 000008ED 50                  <1>     push ax             ; char address
  1074 000008EE 68BE00              <1>     push 190            ; y
  1075 000008F1 682201              <1>     push 290             ; x
  1076 000008F4 E86302              <1>     call write_char_from_bitmap_address
  1077 000008F7 83C406              <1>     add sp, 6
  1078                              <1> 
  1079                              <1>     ; word_h, high nibble
  1080 000008FA 8B76FE              <1>     mov si, [bp - 2]
  1081 000008FD C1E600              <1>     shl si, 0
  1082 00000900 C1EE0C              <1>     shr si, 12
  1083 00000903 8A9C[3702]          <1>     mov bl, byte [hex_print_table + si]
  1084 00000907 30FF                <1>     xor bh, bh
  1085                              <1> 
  1086 00000909 89D8                <1>     mov ax, bx
  1087 0000090B E8A301              <1>     call char_ascii_to_bitmap_address
  1088 0000090E 50                  <1>     push ax             ; char address
  1089 0000090F 68BE00              <1>     push 190            ; y
  1090 00000912 681801              <1>     push 280             ; x
  1091 00000915 E84202              <1>     call write_char_from_bitmap_address
  1092 00000918 83C406              <1>     add sp, 6
  1093                              <1> 
  1094                              <1> 
  1095 0000091B 58                  <1>     pop ax
  1096                              <1> 
  1097 0000091C 89EC                <1>     mov sp, bp
  1098 0000091E 5D                  <1>     pop bp
  1099 0000091F C3                  <1>     ret
  1100                              <1> print_hex_value_end:
  1101                              <1> 
  1102                              <1> 
  1103                              <1> 
  1104                              <1> print_available_chars:
  1105                              <1> 
  1106 00000920 B83000              <1>     mov ax, '0'
  1107 00000923 E88B01              <1>     call char_ascii_to_bitmap_address
  1108 00000926 50                  <1>     push ax             ; char address
  1109 00000927 68BE00              <1>     push 190            ; y
  1110 0000092A 6A0A                <1>     push 10             ; x
  1111 0000092C E82B02              <1>     call write_char_from_bitmap_address
  1112 0000092F 83C406              <1>     add sp, 6
  1113                              <1> 
  1114                              <1> 
  1115 00000932 B83100              <1>     mov ax, '1'
  1116 00000935 E87901              <1>     call char_ascii_to_bitmap_address
  1117 00000938 50                  <1>     push ax          ; Letter address
  1118 00000939 68BE00              <1>     push 190            ; y
  1119 0000093C 6A14                <1>     push 20             ; x
  1120 0000093E E81902              <1>     call write_char_from_bitmap_address
  1121 00000941 83C406              <1>     add sp, 6
  1122                              <1> 
  1123 00000944 B83200              <1>     mov ax, '2'
  1124 00000947 E86701              <1>     call char_ascii_to_bitmap_address
  1125 0000094A 50                  <1>     push ax          ; Letter address
  1126 0000094B 68BE00              <1>     push word 190           ; y
  1127 0000094E 6A1E                <1>     push word 30            ; x
  1128 00000950 E80702              <1>     call write_char_from_bitmap_address
  1129 00000953 83C406              <1>     add sp, 6
  1130                              <1> 
  1131 00000956 B83300              <1>     mov ax, '3'
  1132 00000959 E85501              <1>     call char_ascii_to_bitmap_address
  1133 0000095C 50                  <1>     push ax          ; Letter address
  1134 0000095D 68BE00              <1>     push 190            ; y
  1135 00000960 6A28                <1>     push 40             ; x
  1136 00000962 E8F501              <1>     call write_char_from_bitmap_address
  1137 00000965 83C406              <1>     add sp, 6
  1138                              <1> 
  1139 00000968 B83400              <1>      mov ax, '4'
  1140 0000096B E84301              <1>     call char_ascii_to_bitmap_address
  1141 0000096E 50                  <1>     push ax          ; Letter address
  1142 0000096F 68BE00              <1>     push 190            ; y
  1143 00000972 6A28                <1>     push 40             ; x
  1144 00000974 E8E301              <1>     call write_char_from_bitmap_address
  1145 00000977 83C406              <1>     add sp, 6
  1146                              <1> 
  1147 0000097A B83500              <1>     mov ax, '5'
  1148 0000097D E83101              <1>     call char_ascii_to_bitmap_address
  1149 00000980 50                  <1>     push ax          ; Letter address
  1150 00000981 68BE00              <1>     push word 190           ; y
  1151 00000984 6A32                <1>     push word 50            ; x
  1152 00000986 E8D101              <1>     call write_char_from_bitmap_address
  1153 00000989 83C406              <1>     add sp, 6
  1154                              <1> 
  1155 0000098C B83600              <1>     mov ax, '6'
  1156 0000098F E81F01              <1>     call char_ascii_to_bitmap_address
  1157 00000992 50                  <1>     push ax          ; Letter address
  1158 00000993 68BE00              <1>     push 190            ; y
  1159 00000996 6A3C                <1>     push 60             ; x
  1160 00000998 E8BF01              <1>     call write_char_from_bitmap_address
  1161 0000099B 83C406              <1>     add sp, 6
  1162                              <1> 
  1163 0000099E B83600              <1>     mov ax, '6'
  1164 000009A1 E80D01              <1>     call char_ascii_to_bitmap_address
  1165 000009A4 50                  <1>     push ax          ; Letter address
  1166 000009A5 68BE00              <1>     push 190            ; y
  1167 000009A8 6A46                <1>     push 70             ; x
  1168 000009AA E8AD01              <1>     call write_char_from_bitmap_address
  1169 000009AD 83C406              <1>     add sp, 6
  1170                              <1> 
  1171 000009B0 B83700              <1>      mov ax, '7'
  1172 000009B3 E8FB00              <1>     call char_ascii_to_bitmap_address
  1173 000009B6 50                  <1>     push ax          ; Letter address
  1174 000009B7 68BE00              <1>     push 190            ; y
  1175 000009BA 6A50                <1>     push 80             ; x
  1176 000009BC E89B01              <1>     call write_char_from_bitmap_address
  1177 000009BF 83C406              <1>     add sp, 6
  1178                              <1> 
  1179 000009C2 B83800              <1>     mov ax, '8'
  1180 000009C5 E8E900              <1>     call char_ascii_to_bitmap_address
  1181 000009C8 50                  <1>     push ax          ; Letter address
  1182 000009C9 68BE00              <1>     push word 190           ; y
  1183 000009CC 6A5A                <1>     push word 90            ; x
  1184 000009CE E88901              <1>     call write_char_from_bitmap_address
  1185 000009D1 83C406              <1>     add sp, 6
  1186                              <1> 
  1187 000009D4 B83900              <1>     mov ax, '9'
  1188 000009D7 E8D700              <1>     call char_ascii_to_bitmap_address
  1189 000009DA 50                  <1>     push ax          ; Letter address
  1190 000009DB 68BE00              <1>     push 190            ; y
  1191 000009DE 6A64                <1>     push 100             ; x
  1192 000009E0 E87701              <1>     call write_char_from_bitmap_address
  1193 000009E3 83C406              <1>     add sp, 6
  1194                              <1> 
  1195                              <1> 
  1196 000009E6 B84100              <1>     mov ax, 'A'
  1197 000009E9 E8C500              <1>     call char_ascii_to_bitmap_address
  1198                              <1>     ; mov si, ax          ; Letter address
  1199 000009EC 50                  <1>     push ax          ; Letter address
  1200 000009ED 68BE00              <1>     push 190            ; y
  1201 000009F0 6A6E                <1>     push 110             ; x
  1202 000009F2 E86501              <1>     call write_char_from_bitmap_address
  1203 000009F5 83C406              <1>     add sp, 6
  1204                              <1> 
  1205 000009F8 B84200              <1>     mov ax, 'B'
  1206 000009FB E8B300              <1>     call char_ascii_to_bitmap_address
  1207                              <1>     ; mov si, char_B          ; Letter address
  1208 000009FE 50                  <1>     push ax          ; Letter address
  1209 000009FF 68BE00              <1>     push word 190           ; y
  1210 00000A02 6A78                <1>     push word 120            ; x
  1211 00000A04 E85301              <1>     call write_char_from_bitmap_address
  1212 00000A07 83C406              <1>     add sp, 6
  1213                              <1> 
  1214 00000A0A B84300              <1>     mov ax, 'C'
  1215 00000A0D E8A100              <1>     call char_ascii_to_bitmap_address
  1216 00000A10 BE[A702]            <1>     mov si, char_C      ; Letter address
  1217 00000A13 50                  <1>     push ax          ; Letter address
  1218 00000A14 68BE00              <1>     push 190            ; y
  1219 00000A17 688200              <1>     push 130             ; x
  1220 00000A1A E83D01              <1>     call write_char_from_bitmap_address
  1221 00000A1D 83C406              <1>     add sp, 6
  1222                              <1> 
  1223 00000A20 B84400              <1>      mov ax, 'D'
  1224 00000A23 E88B00              <1>     call char_ascii_to_bitmap_address
  1225                              <1>     ; mov si, ax          ; Letter address
  1226 00000A26 50                  <1>     push ax          ; Letter address
  1227 00000A27 68BE00              <1>     push 190            ; y
  1228 00000A2A 688C00              <1>     push 140             ; x
  1229 00000A2D E82A01              <1>     call write_char_from_bitmap_address
  1230 00000A30 83C406              <1>     add sp, 6
  1231                              <1> 
  1232 00000A33 B84500              <1>     mov ax, 'E'
  1233 00000A36 E87800              <1>     call char_ascii_to_bitmap_address
  1234                              <1>     ; mov si, char_B          ; Letter address
  1235 00000A39 50                  <1>     push ax          ; Letter address
  1236 00000A3A 68BE00              <1>     push word 190           ; y
  1237 00000A3D 689600              <1>     push word 150            ; x
  1238 00000A40 E81701              <1>     call write_char_from_bitmap_address
  1239 00000A43 83C406              <1>     add sp, 6
  1240                              <1> 
  1241 00000A46 B84600              <1>     mov ax, 'F'
  1242 00000A49 E86500              <1>     call char_ascii_to_bitmap_address
  1243 00000A4C BE[A702]            <1>     mov si, char_C      ; Letter address
  1244 00000A4F 50                  <1>     push ax          ; Letter address
  1245 00000A50 68BE00              <1>     push 190            ; y
  1246 00000A53 68A000              <1>     push 160             ; x
  1247 00000A56 E80101              <1>     call write_char_from_bitmap_address
  1248 00000A59 83C406              <1>     add sp, 6
  1249                              <1> 
  1250 00000A5C C3                  <1>     ret
  1251                              <1> 
  1252                              <1> ; loop throught the cursor buffer, printing output at fixed row (2?)
  1253                              <1> write_whole_cursor_buffer:
  1254                              <1> 
  1255 00000A5D BB[5700]            <1>     mov bx, cursor_buffer       ; buffer address
  1256                              <1>     ; Indexes
  1257 00000A60 8B0E[5701]          <1>     mov cx, word [cursor_count] ; loop decrement - index
  1258 00000A64 BE0000              <1>     mov si, 0x0000              ; current char index in buffer
  1259                              <1>     .print_cursor_buffer:
  1260                              <1>     
  1261                              <1> 
  1262                              <1>     ; move char from buffer and get char address
  1263 00000A67 8A00                <1>     mov al, byte [bx + si]
  1264 00000A69 30E4                <1>     xor ah, ah
  1265 00000A6B E84300              <1>     call char_ascii_to_bitmap_address
  1266                              <1> 
  1267                              <1>     ; set cursor x location
  1268 00000A6E 89F2                <1>     mov dx, si                  ; buffer index
  1269 00000A70 0FAF16[5D01]        <1>     imul dx, word [cursor_w]    ; cursor width
  1270                              <1> 
  1271                              <1>     ; set cursor y location (fixed for now)
  1272 00000A75 BF1200              <1>     mov di, 18 ; second row
  1273 00000A78 0FAF3E[5F01]        <1>     imul di, word [cursor_h]
  1274                              <1>     
  1275                              <1> 
  1276                              <1>     ; perists across call
  1277 00000A7D 56                  <1>     push si
  1278 00000A7E 51                  <1>     push cx
  1279                              <1> 
  1280 00000A7F 50                  <1>     push ax             ; char bitmap address
  1281 00000A80 57                  <1>     push di             ; y
  1282 00000A81 52                  <1>     push dx             ; x
  1283 00000A82 E8D500              <1>     call write_char_from_bitmap_address
  1284 00000A85 83C406              <1>     add sp, 6
  1285                              <1> 
  1286 00000A88 59                  <1>     pop cx
  1287 00000A89 5E                  <1>     pop si
  1288                              <1> 
  1289                              <1>     ; call 
  1290                              <1>     ; mov ax, word [ascii_current_press]
  1291                              <1>     ; call write_char_at_cursor
  1292                              <1> 
  1293 00000A8A 46                  <1>     inc si
  1294 00000A8B 49                  <1>     dec cx
  1295 00000A8C 83F900              <1>     cmp word cx, 0
  1296 00000A8F 7FD6                <1>     jg .print_cursor_buffer
  1297                              <1>     ; loop .print_cursor_buffer
  1298                              <1> 
  1299                              <1>     ; DEBUG
  1300                              <1>     ; cli 
  1301                              <1>     ; hlt
  1302                              <1> 
  1303 00000A91 C3                  <1>     ret
  1304                              <1> 
  1305                              <1> 
  1306                              <1> ; input     : ax = char ascii value
  1307                              <1> ; WILL ONLY RENDER FOR NEXT FRAME ONE FRAME!
  1308                              <1> ; NO INCREMENT
  1309                              <1> write_ascii_char_at_cursor:
  1310                              <1>     ; mov ax, 'A'
  1311 00000A92 E81C00              <1>     call char_ascii_to_bitmap_address
  1312                              <1>     ; ax = bitmap address
  1313                              <1>     
  1314                              <1>     ; set cursor x location
  1315 00000A95 8B1E[5901]          <1>     mov bx, word [cursor_c]
  1316                              <1>     ; inc word [cursor_c]
  1317 00000A99 0FAF1E[5D01]        <1>     imul bx, word [cursor_w]
  1318                              <1> 
  1319                              <1>     ; set cursor y location (fixed for now)
  1320 00000A9E 8B16[5B01]          <1>     mov dx, word [cursor_r]
  1321 00000AA2 0FAF16[5F01]        <1>     imul dx, word [cursor_h]
  1322                              <1> 
  1323                              <1>     ; mov si, ax          ; Letter address
  1324 00000AA7 50                  <1>     push ax
  1325 00000AA8 52                  <1>     push dx            ; y
  1326 00000AA9 53                  <1>     push bx             ; x
  1327 00000AAA E8AD00              <1>     call write_char_from_bitmap_address
  1328 00000AAD 83C406              <1>     add sp, 6
  1329                              <1> 
  1330 00000AB0 C3                  <1>     ret
  1331                              <1> 
  1332                              <1> 
  1333                              <1> ; input     : ax = char ascii value
  1334                              <1> ; return    : ax = bitmap address
  1335                              <1> char_ascii_to_bitmap_address:
  1336                              <1> 
  1337 00000AB1 83F830              <1> .0: cmp ax, 0x30
  1338 00000AB4 7506                <1>     jne .1
  1339 00000AB6 B8[4702]            <1>     mov ax, char_0
  1340 00000AB9 E99D00              <1>     jmp .done
  1341                              <1> 
  1342 00000ABC 83F831              <1> .1: cmp ax, 0x31
  1343 00000ABF 7506                <1>     jne .2
  1344 00000AC1 B8[4F02]            <1>     mov ax, char_1
  1345 00000AC4 E99200              <1>     jmp .done
  1346                              <1> 
  1347 00000AC7 83F832              <1> .2: cmp ax, 0x32
  1348 00000ACA 7506                <1>     jne .3 
  1349 00000ACC B8[5702]            <1>     mov ax, char_2
  1350 00000ACF E98700              <1>     jmp .done
  1351                              <1> 
  1352 00000AD2 83F833              <1> .3: cmp ax, 0x33
  1353 00000AD5 7505                <1>     jne .4 
  1354 00000AD7 B8[5F02]            <1>     mov ax, char_3
  1355 00000ADA EB7D                <1>     jmp .done
  1356                              <1> 
  1357 00000ADC 83F834              <1> .4: cmp ax, 0x34
  1358 00000ADF 7505                <1>     jne .5 
  1359 00000AE1 B8[6702]            <1>     mov ax, char_4
  1360 00000AE4 EB73                <1>     jmp .done
  1361                              <1> 
  1362 00000AE6 83F835              <1> .5: cmp ax, 0x35
  1363 00000AE9 7505                <1>     jne .6
  1364 00000AEB B8[6F02]            <1>     mov ax, char_5
  1365 00000AEE EB69                <1>     jmp .done
  1366                              <1> 
  1367 00000AF0 83F836              <1> .6: cmp ax, 0x36
  1368 00000AF3 7505                <1>     jne .7
  1369 00000AF5 B8[7702]            <1>     mov ax, char_6
  1370 00000AF8 EB5F                <1>     jmp .done
  1371                              <1> 
  1372 00000AFA 83F837              <1> .7: cmp ax, 0x37
  1373 00000AFD 7505                <1>     jne .8
  1374 00000AFF B8[7F02]            <1>     mov ax, char_7
  1375 00000B02 EB55                <1>     jmp .done
  1376                              <1> 
  1377 00000B04 83F838              <1> .8: cmp ax, 0x38
  1378 00000B07 7505                <1>     jne .9 
  1379 00000B09 B8[8702]            <1>     mov ax, char_8
  1380 00000B0C EB4B                <1>     jmp .done
  1381                              <1> 
  1382 00000B0E 83F839              <1> .9: cmp ax, 0x39
  1383 00000B11 7505                <1>     jne .A
  1384 00000B13 B8[8F02]            <1>     mov ax, char_9
  1385 00000B16 EB41                <1>     jmp .done
  1386                              <1> 
  1387 00000B18 83F841              <1> .A: cmp ax, 0x41
  1388 00000B1B 7505                <1>     jne .B
  1389 00000B1D B8[9702]            <1>     mov ax, char_A
  1390 00000B20 EB37                <1>     jmp .done
  1391                              <1> 
  1392 00000B22 83F842              <1> .B: cmp ax, 0x42
  1393 00000B25 7505                <1>     jne .C
  1394 00000B27 B8[9F02]            <1>     mov ax, char_B
  1395 00000B2A EB2D                <1>     jmp .done
  1396                              <1> 
  1397 00000B2C 83F843              <1> .C: cmp ax, 0x43
  1398 00000B2F 7505                <1>     jne .D 
  1399 00000B31 B8[A702]            <1>     mov ax, char_C
  1400 00000B34 EB23                <1>     jmp .done
  1401                              <1> 
  1402 00000B36 83F844              <1> .D: cmp ax, 0x44
  1403 00000B39 7505                <1>     jne .E 
  1404 00000B3B B8[AF02]            <1>     mov ax, char_D
  1405 00000B3E EB19                <1>     jmp .done
  1406                              <1> 
  1407 00000B40 83F845              <1> .E: cmp ax, 0x45
  1408 00000B43 7505                <1>     jne .F 
  1409 00000B45 B8[B702]            <1>     mov ax, char_E
  1410 00000B48 EB0F                <1>     jmp .done
  1411                              <1> 
  1412 00000B4A 83F846              <1> .F: cmp ax, 0x46
  1413 00000B4D 7505                <1>     jne .default ; NOTE THE CUSTOM END OF SWITCHING!
  1414 00000B4F B8[BF02]            <1>     mov ax, char_F
  1415 00000B52 EB05                <1>     jmp .done
  1416                              <1> 
  1417                              <1> .default:
  1418 00000B54 B8[C702]            <1>     mov ax, char_default
  1419 00000B57 EB00                <1>     jmp .done
  1420                              <1> 
  1421                              <1> .done:
  1422 00000B59 C3                  <1>     ret
  1423                              <1> char_ascii_to_bitmap_address_end:
  1424                              <1> 
  1425                              <1> ; routine is heavily commented for the sake of learning!
  1426                              <1> write_char_from_bitmap_address:
  1427 00000B5A 55                  <1>     push bp
  1428 00000B5B 89E5                <1>     mov bp, sp
  1429                              <1> 
  1430                              <1>     ; char bitmap address
  1431 00000B5D 8B7608              <1>     mov si, [bp+8]
  1432                              <1> 
  1433                              <1>     ; set up buffer segment
  1434 00000B60 B80070              <1>     mov ax, VIDEO_D_BUFFER
  1435 00000B63 8EC0                <1>     mov es, ax
  1436                              <1> 
  1437                              <1> 
  1438 00000B65 B90800              <1>     mov cx, 8               ; row loop inex == char height
  1439                              <1> .draw_row:
  1440 00000B68 AC                  <1>     lodsb                   ; load letter byte (si) into ax
  1441 00000B69 51                  <1>     push word cx            ; Save row counter, as cx will be used for column indexing loop
  1442                              <1> 
  1443                              <1>     ; Set leftmost location of new row
  1444 00000B6A 8B7E06              <1>     mov di, [bp+6]          ; Start at the Y-coordinate
  1445 00000B6D 69FF4001            <1>     imul di, 320            ; Multiply Y by screen width (320)
  1446 00000B71 037E04              <1>     add di, [bp+4]          ; Add X-coordinate to get pixel offset
  1447                              <1> 
  1448 00000B74 B90800              <1>     mov cx, 8               ; Column loop index == char width
  1449                              <1> .draw_pixel:
  1450 00000B77 A880                <1>     test al, 10000000b      ; Test the most significant bit (1 pixel)
  1451 00000B79 7404                <1>     jz .next_pixel          ; If 0, skip drawing the pixel
  1452                              <1> 
  1453 00000B7B 26C6050F            <1>     mov byte [es:di], 0x0F  ; DRAW PIXEL
  1454                              <1> 
  1455                              <1> .next_pixel:                ; always move to next pixel
  1456 00000B7F D0E0                <1>     shl al, 1               ; next letter bit for comparison
  1457 00000B81 47                  <1>     inc di                  ; Move to the next framebuffer byte
  1458 00000B82 E2F3                <1>     loop .draw_pixel        ; Repeat for all 8 pixels in the row
  1459                              <1> 
  1460 00000B84 FF4606              <1>     inc word [bp+6]         ; Move to the next row by incrementing y
  1461                              <1> 
  1462 00000B87 59                  <1>     pop word cx             ; Restore row counter
  1463 00000B88 E2DE                <1>     loop .draw_row          ; dec cx + cmp cx, 0 + jnz .draw_row ?
  1464                              <1> 
  1465                              <1> 
  1466 00000B8A 89EC                <1>     mov sp, bp
  1467 00000B8C 5D                  <1>     pop bp
  1468 00000B8D C3                  <1>     ret
  1469                              <1> write_char_from_bitmap_address_end:
  1470                              <1> 
  1471                              <1> 
  1472                              <1> 
  1473                              <1> ; @ x [i16] - bp + 4
  1474                              <1> ; @ y [i16] - bp + 6
  1475                              <1> ; @ c [i16] - bp + 8
  1476                              <1> draw_2x2:
  1477                              <1> 
  1478                              <1>     ; save previous stack frame. Then set up new one. 
  1479 00000B8E 55                  <1>     push bp
  1480 00000B8F 89E5                <1>     mov bp, sp ; can't use stack pointer for effective address calculation
  1481                              <1>     
  1482 00000B91 B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1483 00000B94 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1484                              <1> 
  1485                              <1>     ; Set color
  1486 00000B96 8A5608              <1>     mov dl, BYTE [bp + 8] ; col 1
  1487 00000B99 8A7608              <1>     mov dh, BYTE [bp + 8] ; col 2
  1488                              <1> 
  1489                              <1>     ; set first row y value
  1490 00000B9C BF4001              <1>     mov di, 320
  1491 00000B9F 8B4606              <1>     mov ax, WORD [bp + 6]
  1492 00000BA2 0FAFF8              <1>     imul di, ax ; y
  1493                              <1> 
  1494 00000BA5 8B4604              <1>     mov ax, WORD [bp + 4]
  1495 00000BA8 01C7                <1>     add di, ax ; x
  1496                              <1> 
  1497 00000BAA 268915              <1>     mov [es:di], dx     ; write first pixel row
  1498                              <1> 
  1499                              <1>     ; second row 
  1500 00000BAD 81C74001            <1>     add di, 320
  1501 00000BB1 268915              <1>     mov [es:di], dx     ; write second pixel row
  1502                              <1> 
  1503                              <1>     
  1504                              <1>     ; reset stack to call entrypoint
  1505 00000BB4 89EC                <1>     mov sp, bp
  1506 00000BB6 5D                  <1>     pop bp
  1507                              <1> 
  1508                              <1>     ; Option # 1
  1509 00000BB7 58                  <1>     pop ax ; return adress
  1510 00000BB8 FFE0                <1>     jmp ax
  1511                              <1>     ; Option # 2
  1512 00000BBA C3                  <1>     ret
  1513                              <1> 
  1514                              <1> 
  1515                              <1> draw_wasd_input:
  1516                              <1> 
  1517                              <1> .w:
  1518 00000BBB 833E[4700]01        <1>     cmp WORD [w_pressed], 1
  1519 00000BC0 7512                <1>     jne .a
  1520                              <1> 
  1521                              <1>     ; .w_draw_press:
  1522                              <1>     ; mov ax, 20
  1523                              <1>     ; mov bx, 162
  1524                              <1>     ; mov si, 0x02
  1525                              <1>     ; call pixel_x_cx_y_dx_c_si
  1526                              <1>     ; jmp .a
  1527                              <1> 
  1528 00000BC2 B81400              <1>     mov ax, 20
  1529 00000BC5 BBA000              <1>     mov bx, 160
  1530 00000BC8 B90500              <1>     mov cx, 5 ; width
  1531 00000BCB BA0500              <1>     mov dx, 5 ; height
  1532 00000BCE BE0200              <1>     mov si, 0x02
  1533 00000BD1 E80801              <1>     call draw_square
  1534                              <1> 
  1535                              <1> 
  1536                              <1> 
  1537                              <1>     .a:
  1538 00000BD4 833E[4F00]01        <1>     cmp WORD [a_pressed], 1 ; a = left
  1539 00000BD9 7512                <1>     jne .s
  1540                              <1> 
  1541                              <1>     ; mov ax, 17
  1542                              <1>     ; mov bx, 165
  1543                              <1>     ; mov si, 0x04
  1544                              <1>     ; call pixel_x_cx_y_dx_c_si
  1545                              <1>     ; jmp .wasd_done
  1546 00000BDB B80F00              <1>     mov ax, 15
  1547 00000BDE BBA500              <1>     mov bx, 165
  1548 00000BE1 B90500              <1>     mov cx, 5 ; width
  1549 00000BE4 BA0500              <1>     mov dx, 5 ; height
  1550 00000BE7 BE0400              <1>     mov si, 0x04
  1551 00000BEA E8EF00              <1>     call draw_square
  1552                              <1> 
  1553                              <1> 
  1554                              <1>     .s:
  1555 00000BED 833E[5100]01        <1>     cmp WORD [s_pressed], 1 ; s = down
  1556 00000BF2 7512                <1>     jne .d
  1557                              <1> 
  1558                              <1>     ; mov ax, 20
  1559                              <1>     ; mov bx, 165
  1560                              <1>     ; mov si, 0x0F
  1561                              <1>     ; call pixel_x_cx_y_dx_c_si
  1562                              <1>     ; jmp .wasd_done
  1563                              <1> 
  1564 00000BF4 B81400              <1>     mov ax, 20
  1565 00000BF7 BBA500              <1>     mov bx, 165
  1566 00000BFA B90500              <1>     mov cx, 5 ; width
  1567 00000BFD BA0500              <1>     mov dx, 5 ; height
  1568 00000C00 BE0F00              <1>     mov si, 0x0F
  1569 00000C03 E8D600              <1>     call draw_square
  1570                              <1> 
  1571                              <1> 
  1572                              <1> 
  1573                              <1>     .d:
  1574 00000C06 833E[5300]01        <1>     cmp WORD [d_pressed], 1 ; d = right
  1575 00000C0B 7512                <1>     jne .next
  1576                              <1> 
  1577                              <1>     ; mov ax, 23
  1578                              <1>     ; mov bx, 165
  1579                              <1>     ; mov si, 0x03
  1580                              <1>     ; call pixel_x_cx_y_dx_c_si
  1581                              <1> 
  1582                              <1>     ; SQUARE TEST
  1583 00000C0D B81900              <1>     mov ax, 25
  1584 00000C10 BBA500              <1>     mov bx, 165
  1585 00000C13 B90500              <1>     mov cx, 5 ; width
  1586 00000C16 BA0500              <1>     mov dx, 5 ; height
  1587 00000C19 BE0300              <1>     mov si, 0x03
  1588 00000C1C E8BD00              <1>     call draw_square
  1589                              <1> 
  1590                              <1>     .next:
  1591                              <1> 
  1592                              <1>     
  1593                              <1> 
  1594                              <1> 
  1595                              <1>     .wasd_done:
  1596                              <1> 
  1597 00000C1F C3                  <1>     ret
  1598                              <1> 
  1599                              <1> ; Clear the screen
  1600                              <1> clear_screen_old:
  1601 00000C20 60                  <1>     pusha
  1602 00000C21 B406                <1>     mov ah, 0x06    ; Scroll up function
  1603 00000C23 B000                <1>     mov al, 0       ; Clear entire screen
  1604 00000C25 B708                <1>     mov bh, 0x08    ; dark gray
  1605 00000C27 B500                <1>     mov ch, 0       ; Upper left row
  1606 00000C29 B100                <1>     mov cl, 0       ; Upper left column
  1607 00000C2B B618                <1>     mov dh, 24      ; Lower right row
  1608 00000C2D B24F                <1>     mov dl, 79      ; Lower right column
  1609 00000C2F CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1610 00000C31 61                  <1>     popa
  1611 00000C32 C3                  <1>     ret
  1612                              <1> 
  1613                              <1> 
  1614                              <1> draw_tests:
  1615                              <1> ; 2024-10-31 : six lines added to add two new pixels!
  1616 00000C33 B90200              <1>     mov cx, 2     ; X position for second pixel
  1617 00000C36 BA0200              <1>     mov dx, 2     ; Y position for second pixel
  1618 00000C39 CD10                <1>     int 0x10
  1619 00000C3B B90300              <1>     mov cx, 3     ; X position for second pixel
  1620 00000C3E BA0300              <1>     mov dx, 3     ; Y position for second pixel
  1621 00000C41 CD10                <1>     int 0x10
  1622                              <1> 
  1623                              <1> 
  1624 00000C43 B90300              <1>     mov cx, 3     ; X position for second pixel
  1625 00000C46 BA0300              <1>     mov dx, 3     ; Y position for second pixel
  1626 00000C49 CD10                <1>     int 0x10
  1627                              <1> 
  1628                              <1>     ; 2024-10-31 : testing array
  1629 00000C4B 8B0E[0000]          <1>     mov cx, [word_array]     ; array pos. 5
  1630 00000C4F 8B16[0000]          <1>     mov dx, [word_array]     ; array pos. 5
  1631                              <1>     ; mov cx, 10     ; array pos. 5
  1632                              <1>     ; mov dx, 10     ; array pos. 5
  1633 00000C53 CD10                <1>     int 0x10
  1634                              <1> 
  1635                              <1> 
  1636                              <1> 
  1637                              <1> ; Draw large square -- INTERRUPT BASED
  1638                              <1> draw_large_square:
  1639 00000C55 B406                <1>     mov ah, 0x06    ; Scroll up 
  1640 00000C57 B706                <1>     mov bh, 0x06    ; color
  1641 00000C59 B50A                <1>     mov ch, 10      ; Upper left x of square
  1642 00000C5B B10A                <1>     mov cl, 10      ; Upper left y of square
  1643 00000C5D B614                <1>     mov dh, 20      ; Lower right x of square
  1644 00000C5F B214                <1>     mov dl, 20      ; Lower right y of square
  1645 00000C61 CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1646 00000C63 C3                  <1>     ret
  1647                              <1> 
  1648                              <1> 
  1649                              <1> ; Draw a pixel at (x, y) with color
  1650                              <1> ; mode h13 is set at the beginning of the program
  1651                              <1> mode_13h_pixel_draw:
  1652 00000C64 B800A0              <1>     mov ax,0a000h
  1653 00000C67 8EC0                <1>     mov es,ax
  1654 00000C69 B81400              <1>     mov ax,20    ; y = 20
  1655 00000C6C BB1400              <1>     mov bx,20
  1656 00000C6F C1E008              <1>     shl ax,8
  1657 00000C72 C1E306              <1>     shl bx,6
  1658 00000C75 01D8                <1>     add ax,bx
  1659 00000C77 83C01E              <1>     add ax,30    ; x = 30
  1660 00000C7A 89C7                <1>     mov di,ax
  1661 00000C7C B002                <1>     mov al,2    ; color = 2 = green
  1662 00000C7E 268805              <1>     mov es:[di],al
  1663 00000C81 C3                  <1>     ret
  1664                              <1> 
  1665                              <1> ; Draw the 'current' pixel 
  1666                              <1> draw_input_incrementing_pixel:
  1667                              <1> 
  1668 00000C82 A1[1800]            <1>     mov ax, [pixel_x]
  1669 00000C85 8B1E[1A00]          <1>     mov bx, [pixel_y]
  1670 00000C89 BE0F00              <1>     mov si, 0x0F
  1671 00000C8C E89500              <1>     call pixel_x_cx_y_dx_c_si
  1672                              <1> 
  1673 00000C8F C3                  <1>     ret
  1674                              <1> 
  1675                              <1> 
  1676                              <1> ;  try to understand the key_code values
  1677                              <1> ; Draw al as x, and ah as y
  1678                              <1> draw_keycode_coords:
  1679 00000C90 B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
  1680 00000C92 B00A                <1>     mov al, 0x0A  ; White color
  1681 00000C94 31C9                <1>     xor cx, cx
  1682 00000C96 31D2                <1>     xor dx, dx
  1683 00000C98 8B0E[4300]          <1>     mov cx, [key_code_al]
  1684 00000C9C 8B16[4100]          <1>     mov dx, [key_code_ah]
  1685 00000CA0 CD10                <1>     int 0x10
  1686 00000CA2 C3                  <1>     ret
  1687                              <1> 
  1688                              <1> ; draw pixel test
  1689                              <1> simple_pixel:
  1690 00000CA3 B86400              <1>     mov ax, 100
  1691 00000CA6 BB4600              <1>     mov bx, 70
  1692 00000CA9 BE0F00              <1>     mov si, 0x0f
  1693 00000CAC E87500              <1>     call pixel_x_cx_y_dx_c_si
  1694 00000CAF C3                  <1>     ret
  1695                              <1> 
  1696                              <1> clear:
  1697                              <1>     ; clear screen using graphics mode writing directly to video buffer
  1698 00000CB0 B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for graphics video memory
  1699 00000CB3 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1700 00000CB5 BF0000              <1>     mov di, 0              ; Start at the top-left corner
  1701 00000CB8 B9007D              <1>     mov cx, 320 * 200 / 2  ; rep stosw increments two bytes per iteration
  1702 00000CBB B8CFCF              <1>     mov ax, 0xCFCF ; 2 x mode 13h color palette (1 byte / pixel)
  1703                              <1>     
  1704                              <1>     ; Increments di by 2 each iteration (default DF=0) and loads ax into [es:di] and stops at di=cx?
  1705                              <1>     ; stosw : w=word=eax, stosb : w=byte,
  1706 00000CBE F3AB                <1>     rep stosw
  1707                              <1> 
  1708 00000CC0 C3                  <1>     ret
  1709                              <1> 
  1710                              <1> 
  1711                              <1> 
  1712                              <1> write_oooo:
  1713                              <1>     ; Set cursor position   
  1714                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
  1715                              <1>     ; mov al, 0
  1716                              <1>     ; mov ah, 0x02
  1717                              <1>     ; mov bh, 1
  1718                              <1>     ; mov dh, 10
  1719                              <1>     ; mov dl, 0
  1720                              <1>     ; int 0x10
  1721                              <1> 
  1722 00000CC1 B409                <1>     mov ah, 0x09
  1723 00000CC3 B04F                <1>     mov al, 'O'   ;' write char directly
  1724 00000CC5 B701                <1>     mov bh, 1    ; page?
  1725 00000CC7 B306                <1>     mov bl, 0x06    ; color
  1726 00000CC9 B90A00              <1>     mov cx, 10      ; # times to write
  1727 00000CCC B90100              <1>     mov cx, 1      ; # times to write
  1728 00000CCF CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1729 00000CD1 C3                  <1>     ret
  1730                              <1> 
  1731                              <1> 
  1732                              <1> 
  1733                              <1> 
  1734                              <1> 
  1735                              <1> ; draw square 'local' variables
  1736                              <1> ; I don't have a stack yet...
  1737 00000CD2 0000                <1> sq_hh dw 0
  1738 00000CD4 0000                <1> sq_ww dw 0
  1739 00000CD6 0000                <1> sq_xx dw 0
  1740 00000CD8 0000                <1> sq_yy dw 0
  1741 00000CDA 0000                <1> sq_cc dw 0
  1742                              <1> ; Draw a square at (ax, bx), with (h, w)=(cx, dx), and color=si
  1743                              <1> draw_square:
  1744                              <1>     ; 'push' arguments
  1745 00000CDC A3[D60C]            <1>     mov [sq_xx], ax
  1746 00000CDF 891E[D80C]          <1>     mov [sq_yy], bx
  1747 00000CE3 890E[D40C]          <1>     mov [sq_ww], cx
  1748 00000CE7 8916[D20C]          <1>     mov [sq_hh], dx
  1749 00000CEB 8936[DA0C]          <1>     mov [sq_cc], si
  1750                              <1> 
  1751                              <1> ; video segment
  1752 00000CEF B80070              <1>     mov ax, VIDEO_D_BUFFER
  1753 00000CF2 8EC0                <1>     mov es, ax
  1754                              <1> 
  1755                              <1> 
  1756                              <1> ; row-index
  1757 00000CF4 B90000              <1>     mov cx, 0
  1758                              <1> .L_ROW:
  1759                              <1>     ; Set di to point to leftmost in current row
  1760 00000CF7 8B3E[D80C]          <1>     mov di, [sq_yy]
  1761 00000CFB 01CF                <1>     add di, cx
  1762 00000CFD 69FF4001            <1>     imul di, 320 ; y
  1763 00000D01 033E[D60C]          <1>     add di, [sq_xx] ; x
  1764                              <1>     
  1765                              <1> 
  1766                              <1> ; column-index
  1767 00000D05 BA0000              <1>     mov dx, 0
  1768                              <1> .L_COLUMN:
  1769                              <1> 
  1770                              <1>     ; DRAW PIXEL
  1771 00000D08 A0[DA0C]            <1>     mov al, [sq_cc] ; color
  1772 00000D0B 268805              <1>     mov [es:di], al ; location
  1773                              <1> 
  1774                              <1>     ; next pixel location -- x-direction
  1775                              <1>     ; increment AFTER draw to properly draw with zero index
  1776 00000D0E 47                  <1>     inc di
  1777                              <1> 
  1778                              <1>     ; increment col-index until height is reached
  1779 00000D0F 42                  <1>     inc dx
  1780 00000D10 3B16[D40C]          <1>     cmp dx, WORD [sq_ww]
  1781 00000D14 7CF2                <1>     jl .L_COLUMN
  1782                              <1> 
  1783                              <1> .L_COLUMN_END:  
  1784                              <1> 
  1785                              <1>     ; keep incrementing row-index until height is reached
  1786 00000D16 41                  <1>     inc cx
  1787 00000D17 3B0E[D20C]          <1>     cmp cx, WORD [sq_hh]
  1788 00000D1B 7CDA                <1>     jl .L_ROW 
  1789                              <1> 
  1790 00000D1D C3                  <1>     ret
  1791                              <1> 
  1792                              <1> 
  1793                              <1> 
  1794                              <1> 
  1795                              <1> 
  1796                              <1> ; draw pixel variables
  1797 00000D1E 0000                <1> xx dw 0
  1798 00000D20 0000                <1> yy dw 0
  1799 00000D22 0000                <1> cc dw 0
  1800                              <1> ; Draw a pixel at (cx, dx), with color (si)
  1801                              <1> pixel_x_cx_y_dx_c_si:
  1802 00000D24 A3[1E0D]            <1>     mov [xx], ax
  1803 00000D27 891E[200D]          <1>     mov [yy], bx
  1804 00000D2B 8936[220D]          <1>     mov [cc], si
  1805                              <1> 
  1806 00000D2F B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1807 00000D32 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1808                              <1> 
  1809                              <1> 
  1810 00000D34 BF4001              <1>     mov di, 320
  1811 00000D37 0FAF3E[200D]        <1>     imul di, [yy] ; y
  1812 00000D3C 033E[1E0D]          <1>     add di, [xx] ; x
  1813 00000D40 A0[220D]            <1>     mov al, [cc]           ; Pixel color (bright white)
  1814                              <1> 
  1815 00000D43 268805              <1>     mov [es:di], al        ; Write pixel color to video memory
  1816 00000D46 C3                  <1>     ret
  1817                              <1>  
  1818                              <1> 
  1819                              <1> ; single blue and white pixels
  1820                              <1> extern_pixels:
  1821 00000D47 B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
  1822 00000D49 B001                <1>     mov al, 0x01  ; color -- Blue 
  1823 00000D4B B93200              <1>     mov cx, 50
  1824 00000D4E BA3200              <1>     mov dx, 50
  1825 00000D51 CD10                <1>     int 0x10
  1826                              <1> 
  1827                              <1>     ; mov ax, 0xA000
  1828                              <1>     ; add ax, (320 * 50 + 50)
  1829                              <1>     ; mov [ax]
  1830                              <1>     
  1831 00000D53 B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1832 00000D56 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1833                              <1> 
  1834 00000D58 BFF33F              <1>     mov di, (320 * 51 + 51) ; Offset for pixel at (100, 50)
  1835 00000D5B B007                <1>     mov al, 0x07           ; Pixel color (bright white)
  1836                              <1> 
  1837 00000D5D 268805              <1>     mov [es:di], al        ; Write pixel color to video memory
  1838                              <1> 
  1839 00000D60 C3                  <1>     ret
   471                                  %include "./draw/keyboard.asm"
     1                              <1> section .data
     2                              <1> 
     3                              <1> ; KEYBOARD INPUT CODE
     4 0000003F 0000                <1> key_code dw 0
     5 00000041 0000                <1> key_code_ah dw 0
     6 00000043 0000                <1> key_code_al dw 0
     7                              <1> ; mov WORD [key_code_ah], 0
     8                              <1> 
     9                              <1> 
    10                              <1> 
    11                              <1> ; key-flags indicating that the key is currently pressed
    12 00000045 0000                <1> press_event dw 0 ; 1 = pressed, 0 = released
    13 00000047 0000                <1> w_pressed dw 0
    14 00000049 C706[4700]0000      <1> mov WORD [w_pressed], 0x0000
    15 0000004F 0000                <1> a_pressed dw 0
    16 00000051 0000                <1> s_pressed dw 0
    17 00000053 0000                <1> d_pressed dw 0
    18                              <1> 
    19 00000055 0000                <1> ascii_current_press dw 0
    20 00000057 00<rep 100h>        <1> cursor_buffer times 256 db 0
    21 00000157 0000                <1> cursor_count dw 0
    22 00000159 0000                <1> cursor_c dw 0
    23 0000015B 1300                <1> cursor_r dw 19
    24 0000015D 0A00                <1> cursor_w dw 10
    25 0000015F 0A00                <1> cursor_h dw 10
    26                              <1> 
    27                              <1> 
    28                              <1> section .text
    29                              <1> 
    30                              <1> 
    31                              <1> ; Keyboard interrupt handler
    32                              <1> ; Will break the main loop and update the rendered content
    33                              <1> keyboard_handler:
    34                              <1> 
    35 00000D61 60                  <1>     pusha ; Need .286 direcctive? - 2024-10-31 - https://stackoverflow.com/questions/29728171/x86-assembly-set-of-pushes-and-pusha-difference
    36 00000D62 E460                <1>     in al, 0x60  ; Read keyboard scancode
    37                              <1> 
    38                              <1>     ; store key-information on initial interrupt
    39 00000D64 A3[3F00]            <1>     mov [key_code], ax
    40 00000D67 8826[4100]          <1>     mov [key_code_ah], ah
    41 00000D6B A2[4300]            <1>     mov [key_code_al], al
    42                              <1> 
    43                              <1> 
    44                              <1>     ; DETECT KEY PRESS OR RELEASE
    45 00000D6E A880                <1>     test al, 0x80      ; highest bit is press/release flag
    46 00000D70 7511                <1>     jnz .key_released  ; Bit was set = release
    47                              <1> 
    48                              <1>     .key_pressed:
    49 00000D72 C706[4500]0100      <1>     mov WORD [press_event], 0x1
    50                              <1>     ; call .write_press_key_code_char
    51 00000D78 E81201              <1>     call wasd_update
    52                              <1> 
    53                              <1>     ; Register ascii press
    54 00000D7B A1[4300]            <1>     mov ax, word [key_code_al]
    55 00000D7E E81B00              <1>     call store_ascii_pressed
    56                              <1>     
    57 00000D81 EB13                <1>     jmp .key_flag_done
    58                              <1> 
    59                              <1>     .key_released:
    60 00000D83 C706[4500]0000      <1>     mov WORD [press_event], 0x0
    61 00000D89 802E[3F00]80        <1>     sub BYTE [key_code], 0x80 ; get the key release value by subtracting release-flag
    62 00000D8E 802E[4300]80        <1>     sub BYTE [key_code_al], 0x80 ; get the key release value by subtracting release-flag
    63 00000D93 E8F700              <1>     call wasd_update
    64                              <1>     ; call .write_release_key_code_char
    65                              <1>     
    66                              <1>     .key_flag_done:
    67                              <1>     
    68                              <1>     ; call float_tests
    69                              <1> 
    70                              <1> 
    71 00000D96 B020                <1>     mov al, 0x20
    72 00000D98 E620                <1>     out 0x20, al  ; Send EOI to PIC
    73 00000D9A 61                  <1>     popa
    74 00000D9B CF                  <1>     iret ; interrupt - meaning : 2024-10-31
    75                              <1> _keyboard_handler:
    76                              <1> 
    77                              <1> 
    78                              <1> 
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ; input: ax = raw keyboard press 'al' value 
    83                              <1> store_ascii_pressed:
    84                              <1>     ; mov ax, word [key_code_al]
    85                              <1> 
    86                              <1> 
    87 00000D9C 83F80B              <1> ._0: cmp ax, 0x0B
    88 00000D9F 7509                <1>     jne ._1 
    89 00000DA1 C706[5500]3000      <1>     mov word [ascii_current_press], '0'
    90 00000DA7 E9D000              <1>     jmp .match
    91                              <1> 
    92 00000DAA 83F802              <1> ._1: cmp ax, 0x02
    93 00000DAD 7509                <1>     jne ._2
    94 00000DAF C706[5500]3100      <1>     mov word [ascii_current_press], '1'
    95 00000DB5 E9C200              <1>     jmp .match
    96                              <1> 
    97 00000DB8 83F803              <1> ._2: cmp ax, 0x03
    98 00000DBB 7509                <1>     jne ._3
    99 00000DBD C706[5500]3200      <1>     mov word [ascii_current_press], '2'
   100 00000DC3 E9B400              <1>     jmp .match
   101                              <1> 
   102 00000DC6 83F804              <1> ._3: cmp ax, 0x04
   103 00000DC9 7509                <1>     jne ._4
   104 00000DCB C706[5500]3300      <1>     mov word [ascii_current_press], '3'
   105 00000DD1 E9A600              <1>     jmp .match
   106                              <1> 
   107 00000DD4 83F805              <1> ._4: cmp ax, 0x05
   108 00000DD7 7509                <1>     jne ._5
   109 00000DD9 C706[5500]3400      <1>     mov word [ascii_current_press], '4'
   110 00000DDF E99800              <1>     jmp .match
   111                              <1> 
   112 00000DE2 83F806              <1> ._5: cmp ax, 0x06
   113 00000DE5 7509                <1>     jne ._6
   114 00000DE7 C706[5500]3500      <1>     mov word [ascii_current_press], '5'
   115 00000DED E98A00              <1>     jmp .match
   116                              <1> 
   117 00000DF0 83F807              <1> ._6: cmp ax, 0x07
   118 00000DF3 7508                <1>     jne ._7 
   119 00000DF5 C706[5500]3600      <1>     mov word [ascii_current_press], '6'
   120 00000DFB EB7D                <1>     jmp .match
   121                              <1> 
   122 00000DFD 83F808              <1> ._7: cmp ax, 0x08
   123 00000E00 7508                <1>     jne ._8
   124 00000E02 C706[5500]3700      <1>     mov word [ascii_current_press], '7'
   125 00000E08 EB70                <1>     jmp .match
   126                              <1> 
   127 00000E0A 83F809              <1> ._8: cmp ax, 0x09
   128 00000E0D 7508                <1>     jne ._9
   129 00000E0F C706[5500]3800      <1>     mov word [ascii_current_press], '8'
   130 00000E15 EB63                <1>     jmp .match
   131                              <1> 
   132 00000E17 83F80A              <1> ._9: cmp ax, 0x0A
   133 00000E1A 7508                <1>     jne .a
   134 00000E1C C706[5500]3900      <1>     mov word [ascii_current_press], '9'
   135 00000E22 EB56                <1>     jmp .match
   136                              <1> 
   137 00000E24 83F81E              <1> .a: cmp ax, 30
   138 00000E27 7508                <1>     jne .b
   139 00000E29 C706[5500]4100      <1>     mov word [ascii_current_press], 'A'
   140 00000E2F EB49                <1>     jmp .match
   141                              <1> 
   142 00000E31 83F830              <1> .b: cmp ax, 0x30
   143 00000E34 7508                <1>     jne .c
   144 00000E36 C706[5500]4200      <1>     mov word [ascii_current_press], 'B'
   145 00000E3C EB3C                <1>     jmp .match
   146                              <1> 
   147 00000E3E 83F82E              <1> .c: cmp ax, 0x2E
   148 00000E41 7508                <1>     jne .d
   149 00000E43 C706[5500]4300      <1>     mov word [ascii_current_press], 'C'
   150 00000E49 EB2F                <1>     jmp .match
   151                              <1> 
   152 00000E4B 83F820              <1> .d: cmp ax, 32
   153 00000E4E 7508                <1>     jne .e
   154 00000E50 C706[5500]4400      <1>     mov word [ascii_current_press], 'D'
   155 00000E56 EB22                <1>     jmp .match
   156                              <1> 
   157 00000E58 83F812              <1> .e: cmp ax, 18
   158 00000E5B 7508                <1>     jne .f
   159 00000E5D C706[5500]4500      <1>     mov word [ascii_current_press], 'E'
   160 00000E63 EB15                <1>     jmp .match
   161                              <1> 
   162 00000E65 83F821              <1> .f: cmp ax, 33
   163 00000E68 7508                <1>     jne .no_match ; NOTE THE CUSTOM END OF SWITCHING!
   164 00000E6A C706[5500]4600      <1>     mov word [ascii_current_press], 'F'
   165 00000E70 EB08                <1>     jmp .match
   166                              <1> 
   167                              <1> .no_match:
   168 00000E72 C706[5500]0000      <1>     mov word [ascii_current_press], 0x00
   169 00000E78 EB12                <1>     jmp .done
   170                              <1> 
   171                              <1> 
   172                              <1> .match:
   173                              <1>     ; write current press to cursor buffer
   174 00000E7A A1[5500]            <1>     mov ax, word [ascii_current_press]
   175 00000E7D 8B0E[5701]          <1>     mov cx, word [cursor_count] ; current count
   176 00000E81 BB[5700]            <1>     mov bx, cursor_buffer
   177 00000E84 01CB                <1>     add bx, cx
   178 00000E86 8807                <1>     mov byte [bx], al
   179 00000E88 FF06[5701]          <1>     inc word [cursor_count]
   180                              <1> .done:
   181 00000E8C C3                  <1>     ret
   182                              <1> 
   183                              <1> 
   184                              <1> ; Toggle key states
   185                              <1> wasd_update:
   186                              <1> 
   187                              <1> 
   188                              <1> ; SWITCH STATEMENT
   189                              <1> 
   190                              <1> .w:
   191 00000E8D 833E[4300]11        <1>     cmp WORD [key_code_al], 17 ; w = up
   192 00000E92 7517                <1>     jne .a
   193                              <1> 
   194 00000E94 833E[4500]01        <1>     cmp WORD [press_event], 1 ; is pressing
   195 00000E99 7408                <1>     je .w_press
   196                              <1> 
   197                              <1> .w_release:
   198 00000E9B C706[4700]0000      <1>     mov WORD [w_pressed], 0x0000
   199 00000EA1 EB62                <1>     jmp .wasd_done
   200                              <1>     
   201                              <1> .w_press:
   202 00000EA3 C706[4700]0100      <1>     mov WORD [w_pressed], 1
   203 00000EA9 EB5A                <1>     jmp .wasd_done
   204                              <1> 
   205                              <1> 
   206                              <1> 
   207                              <1> .a:
   208 00000EAB 833E[4300]1E        <1>     cmp WORD [key_code_al], 30 ; a = left
   209 00000EB0 7517                <1>     jne .s
   210                              <1> 
   211                              <1> 
   212 00000EB2 833E[4500]01        <1>     cmp WORD [press_event], 1 ; is pressing
   213 00000EB7 7408                <1>     je .a_press
   214                              <1> 
   215                              <1>     .a_release:
   216 00000EB9 C706[4F00]0000      <1>     mov WORD [a_pressed], 0x0000
   217 00000EBF EB44                <1>     jmp .wasd_done
   218                              <1>     
   219                              <1>     .a_press:
   220 00000EC1 C706[4F00]0100      <1>     mov WORD [a_pressed], 1
   221 00000EC7 EB3C                <1>     jmp .wasd_done
   222                              <1> 
   223                              <1> 
   224                              <1> 
   225                              <1> 
   226                              <1> .s:
   227 00000EC9 833E[4300]1F        <1>     cmp WORD [key_code_al], 31 ; s = down
   228 00000ECE 7517                <1>     jne .d
   229                              <1> 
   230 00000ED0 833E[4500]01        <1>     cmp WORD [press_event], 1 ; is pressing
   231 00000ED5 7408                <1>     je .s_press
   232                              <1> 
   233                              <1>     .s_release:
   234 00000ED7 C706[5100]0000      <1>     mov WORD [s_pressed], 0x0000
   235 00000EDD EB26                <1>     jmp .wasd_done
   236                              <1>     
   237                              <1>     .s_press:
   238 00000EDF C706[5100]0100      <1>     mov WORD [s_pressed], 1
   239 00000EE5 EB1E                <1>     jmp .wasd_done
   240                              <1> 
   241                              <1> 
   242                              <1> 
   243                              <1> .d:
   244 00000EE7 833E[4300]20        <1>     cmp WORD [key_code_al], 32 ; d = right
   245 00000EEC 7517                <1>     jne .next
   246                              <1> 
   247                              <1> 
   248 00000EEE 833E[4500]01        <1>     cmp WORD [press_event], 1 ; is pressing
   249 00000EF3 7408                <1>     je .d_press
   250                              <1> 
   251                              <1>     .d_release:
   252 00000EF5 C706[5300]0000      <1>     mov WORD [d_pressed], 0x0000
   253 00000EFB EB08                <1>     jmp .wasd_done
   254                              <1>     
   255                              <1>     .d_press:
   256 00000EFD C706[5300]0100      <1>     mov WORD [d_pressed], 1
   257 00000F03 EB00                <1>     jmp .wasd_done
   258                              <1> 
   259                              <1>     .next:
   260                              <1> 
   261                              <1> .wasd_done:
   262                              <1> 
   263 00000F05 C3                  <1>     ret
   264                              <1> 
   265                              <1> 
   266                              <1> 
   267                              <1> ; Navingating using numpad
   268                              <1> ; checking key_code values against tested numpad input value, and change x/y accodingly
   269                              <1> numpad_navigate:
   270                              <1>     ; xor bx, bx
   271                              <1>     ; xor cx, cx
   272                              <1>     ; xor dx, dx
   273                              <1>     ; make additional draw call based on keyboard input
   274                              <1>     ; mov cx, 10 ; = pixel x location
   275                              <1> 
   276                              <1>     ; mov dx, 201
   277 00000F06 833E[3F00]48        <1>     cmp WORD [key_code], 72 ; numpad 8 = up
   278 00000F0B 7417                <1>     je .up
   279 00000F0D 833E[3F00]4B        <1>     cmp WORD [key_code], 75 ; numpad 4 = left
   280 00000F12 741A                <1>     je .left
   281 00000F14 833E[3F00]4C        <1>     cmp WORD [key_code], 76 ; numpad 5 = down
   282 00000F19 741D                <1>     je .down
   283 00000F1B 833E[3F00]4D        <1>     cmp WORD [key_code], 77 ; numpad 6 = right
   284 00000F20 7420                <1>     je .right
   285                              <1> 
   286 00000F22 EB28                <1>     jmp .not_equal ; no registered key
   287                              <1> 
   288                              <1>     .up:
   289 00000F24 B002                <1>         mov al, 0x02  ;  green
   290 00000F26 66832E[1E00]02      <1>         sub DWORD [y], 2
   291 00000F2C EB20                <1>         jmp .dn
   292                              <1>     .left:
   293 00000F2E B00D                <1>         mov al, 0x0D  ;  pink
   294 00000F30 66832E[1C00]02      <1>         sub DWORD [x], 2
   295 00000F36 EB16                <1>         jmp .dn
   296                              <1>     .down:
   297 00000F38 B001                <1>         mov al, 0x01  ;  blue
   298 00000F3A 668306[1E00]02      <1>         add DWORD [y], 2
   299 00000F40 EB0C                <1>         jmp .dn
   300                              <1>     .right:
   301 00000F42 B00E                <1>         mov al, 0x0E  ;  yellow
   302 00000F44 668306[1C00]02      <1>         add DWORD [x], 2
   303 00000F4A EB02                <1>         jmp .dn
   304                              <1> 
   305                              <1>     .not_equal:
   306 00000F4C B004                <1>     mov al, 0x04  ;  color
   307                              <1> 
   308                              <1>     .dn:
   309                              <1>     ; mov ah, 0x0C  ; BIOS video function: write pixel
   310                              <1>     ; mov al, 0x0F  ; White color
   311                              <1>     ; int 0x10
   312                              <1> 
   313                              <1>     ; Trying to guess values
   314                              <1>     ; mov cx, [key_code]
   315 00000F4E B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
   316                              <1>     ; mov al, 0x0A  ; White color
   317                              <1>     ; xor cx, cx
   318                              <1>     ; xor dx, dx
   319 00000F50 8B0E[1C00]          <1>     mov WORD cx, [x]
   320 00000F54 8B16[1E00]          <1>     mov WORD dx, [y]
   321                              <1>     ; mov dx, y
   322 00000F58 CD10                <1>     int 0x10
   323 00000F5A C3                  <1>     ret
   324                              <1> 
   325                              <1> 
   326                              <1> ; Write some chars using AH=09h 
   327                              <1> .write_release_key_code_char:
   328                              <1>     ; Set cursor position
   329                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
   330 00000F5B B402                <1>     mov ah, 0x02
   331 00000F5D B701                <1>     mov bh, 1
   332 00000F5F B606                <1>     mov dh, 6
   333 00000F61 B200                <1>     mov dl, 0
   334 00000F63 CD10                <1>     int 0x10
   335                              <1> 
   336 00000F65 B409                <1>     mov ah, 0x09
   337 00000F67 A0[3F00]            <1>     mov al, [key_code]
   338 00000F6A B701                <1>     mov bh, 1    ; page?
   339 00000F6C B306                <1>     mov bl, 0x06    ; color
   340 00000F6E B90200              <1>     mov cx, 2      ; # times to write
   341 00000F71 CD10                <1>     int 0x10        ; Call BIOS video interrupt
   342 00000F73 C3                  <1>     ret
   343                              <1> 
   344                              <1> 
   345                              <1> ; Write some chars using AH=09h 
   346                              <1> .write_press_key_code_char:
   347                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
   348 00000F74 B402                <1>     mov ah, 0x02
   349 00000F76 B701                <1>     mov bh, 1
   350 00000F78 B60A                <1>     mov dh, 10
   351 00000F7A B200                <1>     mov dl, 0
   352 00000F7C CD10                <1>     int 0x10
   353                              <1> 
   354 00000F7E B409                <1>     mov ah, 0x09
   355                              <1>     ; mov al, 'A'   ' write char directly
   356 00000F80 A0[3F00]            <1>     mov al, [key_code]
   357 00000F83 B701                <1>     mov bh, 1    ; page?
   358 00000F85 B306                <1>     mov bl, 0x06    ; color
   359                              <1>     ; mov cx, 10      ; # times to write
   360 00000F87 B90100              <1>     mov cx, 1      ; # times to write
   361 00000F8A CD10                <1>     int 0x10        ; Call BIOS video interrupt
   362 00000F8C C3                  <1>     ret
   363                              <1> 
   364                              <1> 
   365                              <1> 
   472                                  ; %include "./draw/text.asm"
   473                                  ; %include "./draw/update_cre_data.asm"
   474                                  code_segment_end:
   475                                  
   476 00000F8D 00<rep 273h>            times 4096-(code_segment_end - code_segment) db 0
   477                                  
   478                                  
   479                                  
   480                                  section .data
   481                                  ; %include "./draw/data.asm"
   482                                  ; my_data equ 0x0900
   483                                  my_data:
   484                                  ; x, y, c
   485 00000161 14003C000000960050-     tri_2d_int_array dw 20, 60, 0, 150, 80, 0, 120, 30, 0
   485 0000016A 00000078001E000000 
   486 00000173 00000000                slope_float dd 0
   487 00000177 0000                    slope_int dw 0
   488                                  
   489 00000179 E803                    test_var dw 1000
   490                                  
   491                                  ; Testing floating point numbers
   492 0000017B E17AA440                float_1 dd 5.14
   493 0000017F 52B8B640                float_2 dd 5.71
   494 00000183 8FC2A141                float_3 dd 20.22
   495 00000187 00000000                float_res dd 0.0
   496 0000018B 0000                    integer_res dw 0
   497                                  
   498                                  
   499                                  ;   Triangulation!
   500                                  ;   
   501 0000018D 000016430000A04200-     position dd 150.0, 80.0, 0.0
   501 00000196 000000             
   502 00000199 000000000000000000-     velocity dd 0.0, 0.0, 0.0
   502 000001A2 000000             
   503                                  ;
   504                                  ;
   505                                  
   506                                  ; Will hold the triangle points to be drawn next
   507                                  ; Expressed in screen coordinates
   508                                  ; 12 bytes
   509 000001A5 8C008C00BE008C008C-     current_triangle_pixels dw  140, 140, 190 ,140 ,140 ,190    ; x0, y0, x1, y1, x2, y2
   509 000001AE 00BE00             
   510                                  ; 36 bytes          ; x0, y0, z0  &  x1, y1, z1 & x2, y2, z2
   511 000001B1 000070420000704200-     current_triangle    dd      60.0,   60.0,                              110.0,  60.0,                              60.0,   110.0,
   511 000001BA 00DC42000070420000-
   511 000001C3 70420000DC42       
   514                                  ; Current, transformed, window coord, float triangle
   515                                  ; Used for triangle drawing
   516 000001C9 00000000                p0_x dd 0.0
   517 000001CD 00000000                p0_y dd 0.0
   518 000001D1 00000000                p1_x dd 0.0
   519 000001D5 00000000                p1_y dd 0.0
   520 000001D9 00000000                p2_x dd 0.0
   521 000001DD 00000000                p2_y dd 0.0
   522 000001E1 0000                    p0_x_int dw 0.0
   523 000001E3 0000                    p0_y_int dw 0.0
   524 000001E5 0000                    p1_x_int dw 0.0
   525 000001E7 0000                    p1_y_int dw 0.0
   526 000001E9 0000                    p2_x_int dw 0.0
   527 000001EB 0000                    p2_y_int dw 0.0
   528                                  ; Signed area values
   529                                  ;
   530                                  ; current pixel location for discrete pixel loop
   531 000001ED 0000                    p_x_int dw 0
   532 000001EF 0000                    p_y_int dw 0
   533                                  ; current triangle loop range
   534 000001F1 0000                    p_x_int_min dw 0
   535 000001F3 0000                    p_x_int_max dw 0
   536 000001F5 0000                    p_y_int_min dw 0
   537 000001F7 0000                    p_y_int_max dw 0
   538                                  ; current pixel as float for signed area calcs
   539 000001F9 00000000                p_x dd 0
   540 000001FD 00000000                p_y dd 0
   541                                  ; Store the signed area calculation to determine if pixel is within triangle, thus if it is to be drawn
   542 00000201 00000000                area_sign_0 dd 0
   543 00000205 0000                    area_sign_int_0 dw 0
   544 00000207 00000000                area_sign_1 dd 0
   545 0000020B 0000                    area_sign_int_1 dw 0
   546 0000020D 00000000                area_sign_2 dd 0
   547 00000211 0000                    area_sign_int_2 dw 0
   548                                  
   549                                  ;
   550                                  ; GEOMETRY - fixed triangles that will be transformed and rendered
   551                                  ; 
   552                                  ; First triangle
   553                                  ; 36 bytes          ; x0, y0, z0  &  x1, y1, z1 & x2, y2, z2
   554 00000213 000070420000704200-     triangle_1  dd      60.0,   60.0,   0.0,                     110.0,  80.0,   0.0,                     60.0,   110.0,  0.0
   554 0000021C 0000000000DC420000-
   554 00000225 A04200000000000070-
   554 0000022E 420000DC4200000000 
   557                                  
   558                                  
   559                                  
   560 00000237 303132333435363738-     hex_print_table: db "0123456789ABCDEF"
   560 00000240 39414243444546     
   561                                  
   562 00000247 7E                      char_0    db 01111110b
   563 00000248 81                                db 10000001b
   564 00000249 81                                db 10000001b
   565 0000024A 81                                db 10000001b
   566 0000024B 81                                db 10000001b
   567 0000024C 81                                db 10000001b
   568 0000024D 81                                db 10000001b
   569 0000024E 7E                                db 01111110b
   570                                  
   571 0000024F 18                      char_1    db 00011000b
   572 00000250 08                                db 00001000b
   573 00000251 08                                db 00001000b
   574 00000252 08                                db 00001000b
   575 00000253 08                                db 00001000b
   576 00000254 08                                db 00001000b
   577 00000255 08                                db 00001000b
   578 00000256 3E                                db 00111110b
   579                                  
   580 00000257 FF                      char_2    db 11111111b
   581 00000258 01                                db 00000001b
   582 00000259 01                                db 00000001b
   583 0000025A FF                                db 11111111b
   584 0000025B 80                                db 10000000b
   585 0000025C 80                                db 10000000b
   586 0000025D 80                                db 10000000b
   587 0000025E FF                                db 11111111b
   588                                  
   589 0000025F FE                      char_3    db 11111110b
   590 00000260 01                                db 00000001b
   591 00000261 01                                db 00000001b
   592 00000262 1F                                db 00011111b
   593 00000263 01                                db 00000001b
   594 00000264 01                                db 00000001b
   595 00000265 01                                db 00000001b
   596 00000266 FE                                db 11111110b
   597                                  
   598 00000267 81                      char_4    db 10000001b
   599 00000268 81                                db 10000001b
   600 00000269 81                                db 10000001b
   601 0000026A FF                                db 11111111b
   602 0000026B 01                                db 00000001b
   603 0000026C 01                                db 00000001b
   604 0000026D 01                                db 00000001b
   605 0000026E 01                                db 00000001b
   606                                  
   607 0000026F FF                      char_5    db 11111111b
   608 00000270 80                                db 10000000b
   609 00000271 80                                db 10000000b
   610 00000272 FF                                db 11111111b
   611 00000273 01                                db 00000001b
   612 00000274 01                                db 00000001b
   613 00000275 01                                db 00000001b
   614 00000276 FF                                db 11111111b
   615                                  
   616 00000277 FF                      char_6    db 11111111b
   617 00000278 80                                db 10000000b
   618 00000279 80                                db 10000000b
   619 0000027A 80                                db 10000000b
   620 0000027B FF                                db 11111111b
   621 0000027C 81                                db 10000001b
   622 0000027D 81                                db 10000001b
   623 0000027E FF                                db 11111111b
   624                                  
   625 0000027F FF                      char_7    db 11111111b
   626 00000280 01                                db 00000001b
   627 00000281 02                                db 00000010b
   628 00000282 04                                db 00000100b
   629 00000283 08                                db 00001000b
   630 00000284 08                                db 00001000b
   631 00000285 08                                db 00001000b
   632 00000286 08                                db 00001000b
   633                                  
   634 00000287 FF                      char_8    db 11111111b
   635 00000288 81                                db 10000001b
   636 00000289 81                                db 10000001b
   637 0000028A FF                                db 11111111b
   638 0000028B 81                                db 10000001b
   639 0000028C 81                                db 10000001b
   640 0000028D 81                                db 10000001b
   641 0000028E FF                                db 11111111b
   642                                  
   643 0000028F FF                      char_9    db 11111111b
   644 00000290 81                                db 10000001b
   645 00000291 81                                db 10000001b
   646 00000292 FF                                db 11111111b
   647 00000293 01                                db 00000001b
   648 00000294 01                                db 00000001b
   649 00000295 01                                db 00000001b
   650 00000296 7E                                db 01111110b
   651                                  
   652                                  
   653 00000297 7E                      char_A    db 01111110b
   654 00000298 81                                db 10000001b
   655 00000299 81                                db 10000001b
   656 0000029A 81                                db 10000001b
   657 0000029B FF                                db 11111111b
   658 0000029C 81                                db 10000001b
   659 0000029D 81                                db 10000001b
   660 0000029E 81                                db 10000001b
   661                                  
   662 0000029F FE                      char_B    db 11111110b
   663 000002A0 82                                db 10000010b
   664 000002A1 82                                db 10000010b
   665 000002A2 FE                                db 11111110b
   666 000002A3 81                                db 10000001b
   667 000002A4 81                                db 10000001b
   668 000002A5 81                                db 10000001b
   669 000002A6 FF                                db 11111111b
   670                                  
   671 000002A7 FF                      char_C    db 11111111b
   672 000002A8 81                                db 10000001b
   673 000002A9 80                                db 10000000b
   674 000002AA 80                                db 10000000b
   675 000002AB 80                                db 10000000b
   676 000002AC 80                                db 10000000b
   677 000002AD 81                                db 10000001b
   678 000002AE FF                                db 11111111b
   679                                  
   680 000002AF FE                      char_D    db 11111110b
   681 000002B0 81                                db 10000001b
   682 000002B1 81                                db 10000001b
   683 000002B2 81                                db 10000001b
   684 000002B3 81                                db 10000001b
   685 000002B4 81                                db 10000001b
   686 000002B5 81                                db 10000001b
   687 000002B6 FE                                db 11111110b
   688                                  
   689 000002B7 FF                      char_E    db 11111111b
   690 000002B8 80                                db 10000000b
   691 000002B9 80                                db 10000000b
   692 000002BA FC                                db 11111100b
   693 000002BB 80                                db 10000000b
   694 000002BC 80                                db 10000000b
   695 000002BD 80                                db 10000000b
   696 000002BE FF                                db 11111111b
   697                                  
   698 000002BF FF                      char_F    db 11111111b
   699 000002C0 80                                db 10000000b
   700 000002C1 80                                db 10000000b
   701 000002C2 FC                                db 11111100b
   702 000002C3 80                                db 10000000b
   703 000002C4 80                                db 10000000b
   704 000002C5 80                                db 10000000b
   705 000002C6 80                                db 10000000b
   706                                  
   707 000002C7 AA                      char_default  db 10101010b
   708 000002C8 AA                                db 10101010b
   709 000002C9 AA                                db 10101010b
   710 000002CA AA                                db 10101010b
   711 000002CB AA                                db 10101010b
   712 000002CC AA                                db 10101010b
   713 000002CD AA                                db 10101010b
   714 000002CE AA                                db 10101010b
   715                                  
   716                                  my_data_end:
   717                                  ; times 512-(my_data_end - my_data) db 0
   718                                  
   719                                  
   720                                  
   721                                  
   722                                  ; GPT - didn't work!
   723                                  ; org 0x7C00              ; The BIOS loads the bootloader at address 0x7C00
   724                                  ; ;;;
   725                                  ; start:
   726                                  ;     ; Set VGA mode 13h (320x200, 256 colors)
   727                                  ;     mov ax, 0x0013
   728                                  ;     int 0x10
   729                                  
   730                                  ;     ; Set ES segment to 0xA000 (start of VGA video memory)
   731                                  ;     mov ax, 0xA000
   732                                  ;     mov es, ax
   733                                  
   734                                  ;     ; Draw pixels in the top-left corner
   735                                  ;     xor di, di          ; Start at video memory offset 0
   736                                  ;     mov cx, 50          ; Draw 50 pixels in total
   737                                  
   738                                  ; draw_pixels:
   739                                  ;     mov al, 0x0F        ; Color 0x0F (white)
   740                                  ;     stosb               ; Store AL at ES:[DI], increment DI
   741                                  ;     loop draw_pixels
   742                                  
   743                                  ;     ; Halt the CPU
   744                                  ;     cli
   745                                  ;     hlt
   746                                  
   747                                  ; times 510-($-$$) db 0   ; Fill the rest of the boot sector with zeros
   748                                  ; dw 0xAA55               ; Boot signature
   749                                  
   750                                  
   751                                  ; [BITS 16]
   752                                  ; absolute 0x1000  ; Define absolute addressing from 0x1000
   753                                  ; absolute_label:
   754                                  
   755                                  ;     jmp 0x0000:0x7C00 ; Infinite loop
