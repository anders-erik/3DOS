     1                                  ;   
     2                                  ;   A raw binary that renders to a qemu vm in real mode
     3                                  ;
     4                                  
     5                                  ; RUN
     6                                  ;
     7                                  ; // source : Claude
     8                                  ; nasm -f bin -o draw.bin boot.asm
     9                                  ; qemu-system-i386 -drive format=raw,file=draw.bin 
    10                                  
    11                                  ; This one from GPT also works! Probably the same BIOS?
    12                                  ; qemu-system-x86_64 -drive format=raw,file=draw.bin // GPT
    13                                  
    14                                  ; DISASSEMBLE
    15                                  ; objdump -b binary -m i386 -D draw.bin
    16                                  
    17                                  
    18                                  
    19                                  %ifdef ELF
    20                                  section .text
    21                                  global _start
    22                                  _start:
    23                                  %else
    24                                  [bits 16]
    25                                  [org 0x7c00]
    26                                  %endif
    27                                  
    28                                  section .text
    29                                  
    30                                  ; variable for boot sector playground
    31 00000000 0000                    boot_x dw 0 ; bugs if defined within boot_sector section
    32                                  
    33                                  
    34                                  
    35                                  ; Boot sector - ran out of boot sector so had to move code to second_sector
    36                                  boot_sector:
    37                                  
    38                                  
    39                                      ; Basic setup
    40 00000002 FA                          cli
    41                                      ; mov ax, 0x0000
    42                                      ; mov cs, ax ; Why doesn't this work? I thought that cs=0 by default, so this should change nothing?
    43 00000003 B80000                      mov ax, 0x0000
    44 00000006 8ED8                        mov ds, ax
    45 00000008 8EC0                        mov es, ax
    46 0000000A 8ED0                        mov ss, ax
    47 0000000C BC007C                      mov sp, 0x7C00
    48                                  
    49                                      ; additional segment registers
    50                                      ; NOT currently in use because they did not exists pre 80386
    51 0000000F B80000                      mov ax, 0x0000
    52 00000012 8EE0                        mov fs, ax
    53 00000014 8EE8                        mov gs, ax
    54 00000016 FB                          sti
    55                                  
    56                                      ; Load second stage     : sector # 2-5 = 0x7e00 - 0x85FF
    57 00000017 B402                        mov ah, 0x02            ; BIOS read sector function
    58 00000019 B008                        mov al, 8               ; Number of sectors to read -- INCREASING THIS WAS CRUCIAL IN MOVING BEYOND BOOT SECTOR
    59 0000001B B500                        mov ch, 0               ; Cylinder number
    60 0000001D B102                        mov cl, 2               ; Sector number (1 is boot sector)
    61 0000001F B600                        mov dh, 0               ; Head number
    62 00000021 B280                        mov dl, 0x80            ; Drive number (first hard disk)
    63 00000023 BB[0002]                    mov bx, code_segment    ; Where to load the sector
    64 00000026 CD13                        int 0x13                ; BIOS interrupt to read disk
    65                                  
    66                                      ; Load data             : sector # 6   = 0x0x8600 - 0x87FF
    67                                      ; This section will automatically be
    68 00000028 B402                        mov ah, 0x02            ; BIOS read sector function
    69 0000002A B004                        mov al, 4               ; Number of sectors to read
    70 0000002C B500                        mov ch, 0               ; Cylinder number
    71 0000002E B10A                        mov cl, 10              ; Sector number (2-9 is code)
    72 00000030 B600                        mov dh, 0               ; Head number
    73 00000032 B280                        mov dl, 0x80            ; Drive number (first hard disk)
    74                                      ; mov ax, 0x0000
    75                                      ; mov es, ax          ; segment
    76 00000034 BB008E                      mov bx, 0x8E00          ; make sure data sectors at the end of the main text sections 
    77                                  
    78 00000037 CD13                        int 0x13                ; BIOS interrupt to read disk
    79                                      
    80                                      
    81                                      
    82                                  
    83                                      ;;
    84                                      ;; START - Boot section playground
    85                                      ;;
    86                                  
    87                                  .mode_13h_and_clear:
    88 00000039 B81300                      mov ax, 0x13
    89 0000003C CD10                        int 0x10
    90                                  
    91 0000003E B406                        mov ah, 0x06    ; Scroll up function
    92 00000040 B000                        mov al, 0       ; Clear entire screen
    93 00000042 B70C                        mov bh, 0x0C    ; Light Red 
    94 00000044 B500                        mov ch, 0       ; Upper left row
    95 00000046 B100                        mov cl, 0       ; Upper left column
    96 00000048 B618                        mov dh, 24      ; Lower right row
    97 0000004A B24F                        mov dl, 79      ; Lower right column
    98 0000004C CD10                        int 0x10        ; Call BIOS video interrupt
    99                                  
   100                                      ; Landing buffer
   101 0000004E B80000                      mov ax, 0x0000
   102 00000051 B80000                      mov ax, 0x0000
   103 00000054 B80000                      mov ax, 0x0000
   104 00000057 B80000                      mov ax, 0x0000
   105 0000005A B80000                      mov ax, 0x0000
   106 0000005D B80000                      mov ax, 0x0000
   107 00000060 B80000                      mov ax, 0x0000
   108 00000063 B80000                      mov ax, 0x0000
   109 00000066 B80000                      mov ax, 0x0000
   110 00000069 B80000                      mov ax, 0x0000
   111 0000006C B80000                      mov ax, 0x0000
   112 0000006F B80000                      mov ax, 0x0000
   113                                  
   114                                  
   115                                      ; draw pixel
   116 00000072 B40C                        mov ah, 0x0C  ; BIOS video function: write pixel
   117 00000074 B00F                        mov al, 0x0F  ; White color
   118 00000076 31C9                        xor cx, cx
   119 00000078 31D2                        xor dx, dx
   120 0000007A FF06[0000]                  inc word [boot_x]
   121 0000007E 813E[0000]0019              cmp word [boot_x], 6400 ; number of iterations and pixels draw until progressing past boot sector
   122 00000084 7D0E                        jge .load_code_segment
   123 00000086 8B0E[0000]                  mov cx, [boot_x]  ; x
   124 0000008A BA0A00                      mov dx, 10  ; y
   125 0000008D CD10                        int 0x10
   126                                  
   127                                      ; jump back into landing buffer
   128                                      ; jmp 0x0000:0x7C25
   129 0000008F EA607C0000                  jmp 0x0000:0x7C60
   130                                      ; jmp 0x0000:0x7C70
   131                                  
   132                                      ;;
   133                                      ;; END - Boot section playground
   134                                      ;;
   135                                  
   136                                  
   137                                      ; mov al, 0x00       ; Exit QEMU with status 0
   138                                      ; out 0x501, al      ; Write to QEMU's debug exit port
   139                                  
   140                                      .load_code_segment:
   141                                      
   142                                      ; jump to segment 2
   143                                      ; jmp 0x0000:0x7E00
   144 00000094 E96901                      jmp code_segment
   145                                  
   146                                  
   147                                  
   148                                  %ifndef ELF
   149 00000097 00<rep 167h>            times 510-($-$$) db 0
   150 000001FE 55AA                    dw 0xaa55
   151                                  %endif
   152                                  
   153                                  
   154                                  
   155                                  
   156                                  
   157                                  
   158                                  
   159                                  
   160                                  
   161                                  
   162                                  
   163                                  section .text
   164                                  ; --------------------------------------------------------
   165                                  ;  CODE SEGMENT @ 0x7e00 (0x7c00 + 0xFF boot sector size)
   166                                  
   167                                  code_segment:
   168                                  
   169                                  
   170                                  
   171                                  
   172                                  
   173                                  
   174                                  ; Set up video mode (320x200, 256 colors)
   175 00000200 B81300                  mov ax, 0x13
   176 00000203 CD10                    int 0x10
   177                                  
   178                                  ; Set up keyboard interrupt handler
   179 00000205 FA                      cli
   180 00000206 C7062400[1C0D]          mov word [0x24], keyboard_handler
   181 0000020C C70626000000            mov word [0x26], 0
   182 00000212 FB                      sti
   183                                  
   184                                  ; mov ax, old_irq0_offset
   185                                  ; mov bx, ds
   186                                  ; mov ax, word [bx]
   187                                  
   188                                  
   189                                  ; Figure out location of word_array, as it is NOT in this location when going through disassembled code
   190                                  ; -->  00000219:  A30086  mov [0x8600],ax
   191                                  ; Turns out that all '.code' sections will be concatenated to the assembled .text sections, and the IP will not run the instructions placed in the .code!
   192                                  ; 
   193 00000213 A3[5202]                mov word [word_array], ax
   194                                  
   195                                  
   196                                  ; section .text
   197                                  
   198                                  
   199                                  ; ; player position
   200                                  ; player_position_x dw 0xA0
   201                                  ; player_position_y dw 0x60
   202                                  
   203                                  timer_setup:
   204                                   ; timer interrupt
   205 00000216 FA                          cli
   206                                  
   207                                      ; Set up PIT for periodic interrupts
   208 00000217 B036                        mov al, 0x36                ; Control word: Mode 3, Square wave generator
   209 00000219 E643                        out PIT_CONTROL_PORT, al
   210                                      ; mov ax, 1193180        ; Set frequency to 100 Hz (adjust as needed)
   211                                  
   212                                      ; minimum : https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interval_Timer
   213 0000021B B8FFFF                      mov ax, 65535 ; ( ~= 1193180 / 18.2)
   214                                      ; mov ax, 39773 ; ( ~= 1193180 / 30 )
   215 0000021E E640                        out PIT_CHANNEL_0, al       ; Low byte
   216 00000220 88E0                        mov al, ah
   217 00000222 E640                        out PIT_CHANNEL_0, al       ; High byte
   218                                  
   219                                  
   220                                      ; Set up custom IRQ0 handler
   221                                      ; Save old handler address
   222 00000224 B80000                      mov ax, 0x0000
   223 00000227 8EC0                        mov es, ax                  ; ES points to interrupt vector table
   224 00000229 BF2000                      mov di, IRQ0_VECTOR * 4
   225                                      ; backup already existing values in table
   226 0000022C 268B05                      mov ax, [es:di]        ; Load offset into AX
   227 0000022F A3[6802]                    mov [old_irq0_offset], ax
   228 00000232 268B4502                    mov ax, [es:di+2]      ; Load segment into AX
   229 00000236 A3[6A02]                    mov [old_irq0_segment], ax
   230                                  
   231                                      ; Set new handler
   232                                      ; cli
   233 00000239 26C705[4602]                mov word [es:di], timer_handler   ; Offset of custom handler
   234 0000023E 268C4D02                    mov word [es:di+2], cs      ; Segment of this code
   235 00000242 FB                          sti                         ; Re-enable interrupts
   236                                  timer_setup_end:
   237                                  
   238                                  
   239                                  
   240                                  
   241                                  ; Main loop
   242                                  ; Stack is untouched at this point
   243                                  main_loop:
   244 00000243 F4                          hlt
   245 00000244 EBFD                        jmp main_loop
   246                                  
   247                                  
   248                                  
   249                                  
   250                                  
   251                                  timer_handler:
   252 00000246 60                          pusha
   253 00000247 FF06[6C02]                  inc word [tick_count]
   254                                  
   255 0000024B 89E5                        mov bp, sp ; bp already pushed duing hanlder entry
   256                                  
   257 0000024D E86400                      call render
   258                                  
   259 00000250 E80600                      call update
   260                                  
   261                                  
   262                                      ; EOI command making sure proper end of interrupt?
   263 00000253 B020                        mov al, 0x20                ; EOI command
   264 00000255 E620                        out 0x20, al                ; Send to PIC command port (0x20)
   265                                  
   266                                      ; End of handler
   267 00000257 61                          popa                       ; Restore all registers
   268 00000258 CF                          iret                      ; Return from interrupt
   269                                  
   270                                  
   271                                  
   272                                  
   273                                  update:
   274 00000259 E80400                      call .update_player_position
   275 0000025C E83200                      call .update_location
   276 0000025F C3                          ret
   277                                  
   278                                  
   279                                  .update_player_position:
   280 00000260 833E[3801]01            .w: cmp word [w_pressed], 1
   281 00000265 7505                        jne .a
   282 00000267 832E[6602]02                sub word [player_position_y], 2
   283                                      
   284 0000026C 833E[4001]01            .a: cmp word [a_pressed], 1
   285 00000271 7505                        jne .s
   286 00000273 832E[6402]02                sub word [player_position_x], 2
   287                                  
   288 00000278 833E[4201]01            .s: cmp word [s_pressed], 1
   289 0000027D 7505                        jne .d
   290 0000027F 8306[6602]02                add word [player_position_y], 2
   291                                  
   292 00000284 833E[4401]01            .d: cmp word [d_pressed], 1
   293 00000289 7505                        jne .update_player_position_end
   294 0000028B 8306[6402]02                add word [player_position_x], 2
   295                                  .update_player_position_end:
   296                                  
   297 00000290 C3                          ret
   298                                  
   299                                  
   300                                  ; Update current pixel position
   301                                  .update_location:
   302 00000291 FF06[5C02]                  inc word [pixel_x]
   303 00000295 813E[5C02]4001              cmp word [pixel_x], 320
   304 0000029B C3                          ret
   305 0000029C C706[5C02]0000              mov word [pixel_x], 0
   306 000002A2 FF06[5E02]                  inc word [pixel_y]
   307 000002A6 813E[5E02]C800              cmp word [pixel_y], 200
   308 000002AC C3                          ret 
   309 000002AD C706[5E02]0000              mov word [pixel_y], 0
   310                                      ; ret
   311                                  .update_location_end:
   312 000002B3 C3                          ret
   313                                  
   314                                  
   315                                  
   316                                  
   317                                  
   318                                  ; float_test:
   319                                  
   320                                  ;     finit
   321                                  
   322                                  ;     ; Load into FPU stack
   323                                  ;     ; top of stack == ST(0)
   324                                  ;     fld dword [float_1]    ; ST(0) = float_1
   325                                  ;     fld dword [float_2]    ; ST(0) = float_2, ST(1) = float_1
   326                                  ;     fld dword [float_3]    ; ST(0) = float_3, ST(1) = float_2, ST(2) = float_1
   327                                  
   328                                  ;     ; what happens if stack is filled?
   329                                  ;     fild word [tri_2d_int_array]
   330                                  
   331                                  
   332                                  ;     ; fxch ; Swaps spot 0 and 1 ??
   333                                  
   334                                  ;     ; operations
   335                                  ;     ; fadd                  ; ST(0) = ST(0) + ST(1)
   336                                  ;     ; fadd ST(1)     ; ST(0) = ST(0) + ST(1)
   337                                  ;     ; fadd
   338                                  ;     fmul                  ; ST(1) = ST(0) * ST(1)
   339                                  ;     ; fdiv                    ; ST(1) = ST(0) / ST(1)
   340                                  
   341                                  ;     ; ; pop the FPU stack into memory
   342                                  ;     ; fstp dword [float_res]
   343                                      
   344                                  
   345                                  ;     ; ; push/load from memory onto FPU stack
   346                                  ;     ; fld dword [float_res]   ; Load 'result' back into ST(0)
   347                                  
   348                                  ;     ; Convert to integer and store in 'integer_result'
   349                                  ;     fistp word [integer_res] ; Convert and pop ST(0)
   350                                  
   351                                  ;     ; Clear stack?
   352                                  ;     ; Realistically does nothing..
   353                                  ;     fstp
   354                                  ;     fstp
   355                                  
   356                                  ;     ; Draw pixel
   357                                  ;     mov ax, VIDEO_D_BUFFER
   358                                  ;     mov es, ax
   359                                  ;     mov di, word [integer_res]
   360                                  ;     mov word [es:di], 0x0F0F
   361                                  ;     ret
   362                                  
   363                                  
   364                                  ; C-like includes
   365                                  %include "./draw/render.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> section .text
     4                              <1> 
     5                              <1> render:
     6 000002B4 55                  <1>     push bp
     7 000002B5 89E5                <1>     mov bp, sp
     8                              <1>     
     9                              <1>     ; pusha
    10 000002B7 E8B109              <1>     call clear
    11                              <1>     ; call clear_screen_old
    12                              <1> 
    13 000002BA E8D303              <1>     call draw_triangle
    14                              <1>     ; cli 
    15                              <1> 
    16                              <1>     ; hlt
    17                              <1> 
    18 000002BD E8B608              <1>     call draw_wasd_input
    19                              <1> 
    20                              <1>     ; call draw_tests
    21                              <1>     ; call draw_large_square
    22                              <1>     ; call mode_13h_pixel_draw
    23 000002C0 E87A09              <1>     call draw_input_incrementing_pixel
    24                              <1>     ; call draw_keycode_coords ; uses interrupts 
    25 000002C3 E83C0A              <1>     call extern_pixels
    26 000002C6 E89509              <1>     call simple_pixel
    27                              <1> 
    28                              <1>     ; draw player position
    29 000002C9 E87105              <1>     call draw_player_position
    30                              <1>     
    31                              <1> 
    32 000002CC E83D05              <1>     call a2x2_cluster
    33                              <1> 
    34                              <1> 
    35                              <1>     ; print current cursor buffer
    36 000002CF E84607              <1>     call write_whole_cursor_buffer
    37                              <1>     
    38                              <1> 
    39                              <1>     ; Print once when new ascii press detected
    40 000002D2 E82305              <1>     call show_current_ascii_press
    41                              <1> 
    42                              <1> 
    43 000002D5 E80306              <1>     call print_available_chars
    44                              <1> 
    45                              <1>     ; mov ax, 0x1234
    46                              <1>     ; mov ax, 0xfa74
    47                              <1>     ; call print_hex_value
    48                              <1> 
    49 000002D8 E80003              <1>     call draw_sine
    50                              <1> 
    51                              <1>     ; call draw_current_triangle
    52                              <1> 
    53                              <1> 
    54                              <1>     ; Triangle 1
    55 000002DB E81000              <1>     call update_triangle_velocity
    56 000002DE E81C00              <1>     call update_triangle_position
    57                              <1> 
    58 000002E1 E82F02              <1>     call transform_triangle_1_into_current
    59 000002E4 E89F02              <1>     call current_triangle_into_pixel_coord
    60                              <1>     ; call draw_current_triangle_points
    61                              <1>     ; call draw_current_triangle
    62                              <1> 
    63                              <1> 
    64                              <1> 
    65 000002E7 E84503              <1>     call swap_buffer
    66                              <1> 
    67 000002EA 89EC                <1>     mov sp, bp  ; return stack pointer
    68 000002EC 5D                  <1>     pop bp      ; restore bp to callers value
    69                              <1>     ; popa
    70 000002ED C3                  <1>     ret
    71                              <1> 
    72                              <1> 
    73                              <1> update_triangle_velocity:
    74 000002EE D906[6E02]          <1>     fld dword [position+0] ; p_x 
    75 000002F2 D906[7A02]          <1>     fld dword [velocity+0] ; v_x 
    76 000002F6 DEC1                <1>     faddp
    77 000002F8 D91E[6E02]          <1>     fstp dword [position+0]
    78 000002FC C3                  <1>     ret
    79                              <1> update_triangle_velocity_end:
    80                              <1> 
    81                              <1> 
    82                              <1> update_triangle_position:
    83 000002FD D906[6E02]          <1>     fld dword [position+0] ; p_x 
    84 00000301 D906[7A02]          <1>     fld dword [velocity+0] ; v_x 
    85 00000305 DEC1                <1>     faddp
    86 00000307 D91E[6E02]          <1>     fstp dword [position+0]
    87 0000030B C3                  <1>     ret
    88                              <1> update_triangle_position_end:
    89                              <1> 
    90                              <1> ;-- set_current_triangle_loop_span  ---
    91                              <1> ;
    92                              <1> ;   Set the x/y bounding box mins and maxs for current triangle.
    93                              <1> ;   
    94                              <1> set_current_triangle_loop_span:
    95 0000030C C706[7600]4001      <1>     mov word [p_x_int_min], 320
    96 00000312 C706[7800]0000      <1>     mov word [p_x_int_max], 0
    97 00000318 C706[7A00]C800      <1>     mov word [p_y_int_min], 200
    98 0000031E C706[7C00]0000      <1>     mov word [p_y_int_max], 0
    99                              <1> 
   100                              <1> .p0_x_min:
   101 00000324 A1[7600]            <1>     mov ax, word [p_x_int_min]
   102 00000327 3906[6600]          <1>     cmp word [p0_x_int], ax
   103 0000032B 7306                <1>     jae .p1_x_min ; mov if not below
   104 0000032D A1[6600]            <1>     mov ax, word [p0_x_int]
   105 00000330 A3[7600]            <1>     mov word [p_x_int_min], ax
   106                              <1> 
   107                              <1> .p1_x_min:
   108 00000333 A1[7600]            <1>     mov ax, word [p_x_int_min]
   109 00000336 3906[6A00]          <1>     cmp word [p1_x_int], ax
   110 0000033A 7306                <1>     jae .p2_x_min ; mov if not below
   111 0000033C A1[6A00]            <1>     mov ax, word [p1_x_int]
   112 0000033F A3[7600]            <1>     mov word [p_x_int_min], ax
   113                              <1> 
   114                              <1> .p2_x_min:
   115 00000342 A1[7600]            <1>     mov ax, word [p_x_int_min]
   116 00000345 3906[6E00]          <1>     cmp word [p2_x_int], ax
   117 00000349 7306                <1>     jae .x_min_done ; mov if not below
   118 0000034B A1[6E00]            <1>     mov ax, word [p2_x_int]
   119 0000034E A3[7600]            <1>     mov word [p_x_int_min], ax
   120                              <1> .x_min_done: 
   121                              <1> 
   122                              <1> 
   123                              <1> .p0_x_max:
   124 00000351 A1[7800]            <1>     mov ax, word [p_x_int_max]
   125 00000354 3906[6600]          <1>     cmp word [p0_x_int], ax
   126 00000358 7606                <1>     jbe .p1_x_max ; new max if above current
   127 0000035A A1[6600]            <1>     mov ax, word [p0_x_int]
   128 0000035D A3[7800]            <1>     mov word [p_x_int_max], ax
   129                              <1> 
   130                              <1> .p1_x_max:
   131 00000360 A1[7800]            <1>     mov ax, word [p_x_int_max]
   132 00000363 3906[6A00]          <1>     cmp word [p1_x_int], ax
   133 00000367 7606                <1>     jbe .p2_x_max ; new max if above current
   134 00000369 A1[6A00]            <1>     mov ax, word [p1_x_int]
   135 0000036C A3[7800]            <1>     mov word [p_x_int_max], ax
   136                              <1> 
   137                              <1> .p2_x_max:
   138 0000036F A1[7800]            <1>     mov ax, word [p_x_int_max]
   139 00000372 3906[6E00]          <1>     cmp word [p2_x_int], ax
   140 00000376 7606                <1>     jbe .x_max_done ; new max if above current
   141 00000378 A1[6E00]            <1>     mov ax, word [p2_x_int]
   142 0000037B A3[7800]            <1>     mov word [p_x_int_max], ax
   143                              <1> .x_max_done: 
   144                              <1> 
   145                              <1> 
   146                              <1> .p0_y_min:
   147 0000037E A1[7A00]            <1>     mov ax, word [p_y_int_min]
   148 00000381 3906[6800]          <1>     cmp word [p0_y_int], ax
   149 00000385 7306                <1>     jae .p1_y_min ; new min if below current
   150 00000387 A1[6800]            <1>     mov ax, word [p0_y_int]
   151 0000038A A3[7A00]            <1>     mov word [p_y_int_min], ax
   152                              <1> 
   153                              <1> .p1_y_min:
   154 0000038D A1[7A00]            <1>     mov ax, word [p_y_int_min]
   155 00000390 3906[6A00]          <1>     cmp word [p1_x_int], ax
   156 00000394 7306                <1>     jae .p2_y_min ; new min if below current
   157 00000396 A1[6A00]            <1>     mov ax, word [p1_x_int]
   158 00000399 A3[7A00]            <1>     mov word [p_y_int_min], ax
   159                              <1> 
   160                              <1> .p2_y_min:
   161 0000039C A1[7A00]            <1>     mov ax, word [p_y_int_min]
   162 0000039F 3906[6E00]          <1>     cmp word [p2_x_int], ax
   163 000003A3 7306                <1>     jae .y_min_done ; new min if below current
   164 000003A5 A1[6E00]            <1>     mov ax, word [p2_x_int]
   165 000003A8 A3[7A00]            <1>     mov word [p_y_int_min], ax
   166                              <1> .y_min_done: 
   167                              <1> 
   168                              <1> 
   169                              <1> .p0_y_max:
   170 000003AB A1[7C00]            <1>     mov ax, word [p_y_int_max]
   171 000003AE 3906[6800]          <1>     cmp word [p0_y_int], ax
   172 000003B2 7606                <1>     jbe .p1_y_max ; new max if above current
   173 000003B4 A1[6800]            <1>     mov ax, word [p0_y_int]
   174 000003B7 A3[7C00]            <1>     mov word [p_y_int_max], ax
   175                              <1> 
   176                              <1> .p1_y_max:
   177 000003BA A1[7C00]            <1>     mov ax, word [p_y_int_max]
   178 000003BD 3906[6C00]          <1>     cmp word [p1_y_int], ax
   179 000003C1 7606                <1>     jbe .p2_y_max ; new max if above current
   180 000003C3 A1[6C00]            <1>     mov ax, word [p1_y_int]
   181 000003C6 A3[7C00]            <1>     mov word [p_y_int_max], ax
   182                              <1> 
   183                              <1> .p2_y_max:
   184 000003C9 A1[7C00]            <1>     mov ax, word [p_y_int_max]
   185 000003CC 3906[7000]          <1>     cmp word [p2_y_int], ax
   186 000003D0 7606                <1>     jbe .y_max_done ; new max if above current
   187 000003D2 A1[7000]            <1>     mov ax, word [p2_y_int]
   188 000003D5 A3[7C00]            <1>     mov word [p_y_int_max], ax
   189                              <1> .y_max_done: 
   190                              <1> 
   191                              <1> 
   192 000003D8 C3                  <1>     ret
   193                              <1> set_current_triangle_loop_span_end:
   194                              <1> 
   195                              <1> 
   196                              <1> ; ---   draw_current_triangle ------
   197                              <1> ;
   198                              <1> ;   1. sets triangle bounding box values (p_x_int_min, p_x_int_max, p_y_int_min, p_y_int_max)
   199                              <1> ;   2. loops through bounding box integer values
   200                              <1> ;   3. sets all three current triangle signed areas
   201                              <1> ;       4. draw pixel IFF all signed areas are positive (the front of triangle defined using right hand rule)
   202                              <1> ;
   203                              <1> draw_current_triangle:
   204 000003D9 55                  <1>     push bp
   205 000003DA 89E5                <1>     mov bp, sp
   206                              <1> 
   207 000003DC E82DFF              <1>     call set_current_triangle_loop_span
   208                              <1> 
   209                              <1>     ; Loop through pixel row 150
   210 000003DF A1[7600]            <1>     mov ax, word [p_x_int_min]
   211 000003E2 A3[7200]            <1>     mov word [p_x_int], ax   ; start col
   212                              <1> 
   213 000003E5 A1[7A00]            <1>     mov ax, word [p_y_int_min]
   214 000003E8 A3[7400]            <1>     mov word [p_y_int], ax ; start row
   215                              <1> 
   216 000003EB A1[7C00]            <1>     mov ax, word [p_y_int_max]
   217 000003EE 89C1                <1>     mov cx, ax ; last row
   218                              <1>     .next_row:
   219                              <1>     
   220 000003F0 A1[7600]            <1>     mov ax, word [p_x_int_min]
   221 000003F3 A3[7200]            <1>     mov word [p_x_int], ax   ; reset col to lowest x value of current triangle
   222                              <1> 
   223 000003F6 8B16[7800]          <1>     mov dx, word [p_x_int_max] ; last col
   224                              <1>     .next_col:
   225                              <1> 
   226                              <1>     ; Update the float values to current integer indexes
   227 000003FA DF06[7200]          <1>     fild word [p_x_int]
   228 000003FE D91E[7E00]          <1>     fstp dword [p_x]
   229 00000402 DF06[7400]          <1>     fild word [p_y_int]
   230 00000406 D91E[8200]          <1>     fstp dword [p_y]
   231                              <1> 
   232                              <1>     ; check if we should draw
   233                              <1>     ; if all are POSITIVE, draw pixel!
   234 0000040A E83700              <1>     call calc_signed_area_0
   235 0000040D 83F801              <1>     cmp ax, 1
   236 00000410 751A                <1>     jne .end_draw
   237 00000412 E87400              <1>     call calc_signed_area_1
   238 00000415 83F801              <1>     cmp ax, 1
   239 00000418 7512                <1>     jne .end_draw
   240 0000041A E8B100              <1>     call calc_signed_area_2
   241 0000041D 83F801              <1>     cmp ax, 1
   242 00000420 750A                <1>     jne .end_draw
   243                              <1>     
   244                              <1> 
   245 00000422 8B1E[7400]          <1>     mov bx, word [p_y_int]
   246 00000426 A1[7200]            <1>     mov ax, word [p_x_int]
   247 00000429 E86903              <1>     call pixel_xa_yb
   248                              <1> 
   249                              <1>     .end_draw:
   250                              <1> 
   251 0000042C FF06[7200]          <1>     inc word [p_x_int]
   252 00000430 3916[7200]          <1>     cmp word [p_x_int], dx
   253 00000434 72C4                <1>     jb .next_col
   254                              <1> 
   255 00000436 FF06[7400]          <1>     inc word [p_y_int]
   256 0000043A 390E[7400]          <1>     cmp word [p_y_int], cx
   257 0000043E 72B0                <1>     jb .next_row
   258                              <1> 
   259 00000440 89EC                <1>     mov sp, bp
   260 00000442 5D                  <1>     pop bp
   261 00000443 C3                  <1>     ret
   262                              <1> draw_current_triangle_end:
   263                              <1> 
   264                              <1> 
   265                              <1> 
   266                              <1> 
   267                              <1> ;---- calc_signed_area_a to calc_signed_area_c -------
   268                              <1> ;
   269                              <1> ;   variables used: [fixed memory locations]
   270                              <1> ;       p_x, pa_x, pb_x
   271                              <1> ;       area_sign_int_a, area_sign_a
   272                              <1> ;
   273                              <1> ;   returns : ax = 1 if sign is positive
   274                              <1> ;
   275                              <1> ;   https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
   276                              <1> ;   
   277                              <1> ;   compare current point 'p' with line from p_a to p_b
   278                              <1> ;   (p_x - pb_x) * (pa_y - pb_y) - (pa_x - pb_x) * (p_y - pb_y)
   279                              <1> ;   = T1 - T2
   280                              <1> ; 
   281                              <1> ;   POSTFIX: 
   282                              <1> ;       T1 = p_x pb_x - pa_y pb_y - *
   283                              <1> ;       T2 = pa_x pb_x - p_y pb_y - *
   284                              <1> ;       
   285                              <1> ;       T1 - T2 = p_x pb_x - pa_y pb_y - * pa_x pb_x - p_y pb_y - * -
   286                              <1> ;
   287                              <1> calc_signed_area_0:
   288                              <1> 
   289 00000444 D906[7E00]          <1>     fld dword [p_x]
   290 00000448 D906[5600]          <1>     fld dword [p1_x]
   291 0000044C DEE9                <1>     fsubp
   292 0000044E D906[5200]          <1>     fld dword [p0_y]
   293 00000452 D906[5A00]          <1>     fld dword [p1_y]
   294 00000456 DEE9                <1>     fsubp
   295 00000458 DEC9                <1>     fmulp
   296                              <1> 
   297 0000045A D906[4E00]          <1>     fld dword [p0_x]
   298 0000045E D906[5600]          <1>     fld dword [p1_x]
   299 00000462 DEE9                <1>     fsubp
   300 00000464 D906[8200]          <1>     fld dword [p_y]
   301 00000468 D906[5A00]          <1>     fld dword [p1_y]
   302 0000046C DEE9                <1>     fsubp
   303 0000046E DEC9                <1>     fmulp
   304                              <1> 
   305 00000470 DEE9                <1>     fsubp
   306                              <1> 
   307                              <1>     
   308 00000472 DF16[9200]          <1>     fist word [area_sign_int_0]
   309 00000476 D91E[8600]          <1>     fstp dword [area_sign_0]
   310                              <1> 
   311 0000047A 833E[9200]00        <1>     cmp word [area_sign_int_0], 0
   312 0000047F 7C04                <1>     jl .negative
   313 00000481 B80100              <1>     mov ax, 1
   314 00000484 C3                  <1>     ret
   315                              <1>     .negative:
   316 00000485 B80000              <1>     mov ax, 0
   317 00000488 C3                  <1>     ret
   318                              <1> calc_signed_area_0_end:
   319                              <1> calc_signed_area_1:
   320                              <1> 
   321 00000489 D906[7E00]          <1>     fld dword [p_x]
   322 0000048D D906[5E00]          <1>     fld dword [p2_x]
   323 00000491 DEE9                <1>     fsubp
   324 00000493 D906[5A00]          <1>     fld dword [p1_y]
   325 00000497 D906[6200]          <1>     fld dword [p2_y]
   326 0000049B DEE9                <1>     fsubp
   327 0000049D DEC9                <1>     fmulp
   328                              <1> 
   329 0000049F D906[5600]          <1>     fld dword [p1_x]
   330 000004A3 D906[5E00]          <1>     fld dword [p2_x]
   331 000004A7 DEE9                <1>     fsubp
   332 000004A9 D906[8200]          <1>     fld dword [p_y]
   333 000004AD D906[6200]          <1>     fld dword [p2_y]
   334 000004B1 DEE9                <1>     fsubp
   335 000004B3 DEC9                <1>     fmulp
   336                              <1> 
   337 000004B5 DEE9                <1>     fsubp
   338                              <1> 
   339                              <1>     
   340 000004B7 DF16[9400]          <1>     fist word [area_sign_int_1]
   341 000004BB D91E[8A00]          <1>     fstp dword [area_sign_1]
   342                              <1> 
   343 000004BF 833E[9400]00        <1>     cmp word [area_sign_int_1], 0
   344 000004C4 7C04                <1>     jl .negative
   345 000004C6 B80100              <1>     mov ax, 1
   346 000004C9 C3                  <1>     ret
   347                              <1>     .negative:
   348 000004CA B80000              <1>     mov ax, 0
   349 000004CD C3                  <1>     ret
   350                              <1> calc_signed_area_1_end:
   351                              <1> calc_signed_area_2:
   352                              <1> 
   353 000004CE D906[7E00]          <1>     fld dword [p_x]
   354 000004D2 D906[4E00]          <1>     fld dword [p0_x]
   355 000004D6 DEE9                <1>     fsubp
   356 000004D8 D906[6200]          <1>     fld dword [p2_y]
   357 000004DC D906[5200]          <1>     fld dword [p0_y]
   358 000004E0 DEE9                <1>     fsubp
   359 000004E2 DEC9                <1>     fmulp
   360                              <1> 
   361 000004E4 D906[5E00]          <1>     fld dword [p2_x]
   362 000004E8 D906[4E00]          <1>     fld dword [p0_x]
   363 000004EC DEE9                <1>     fsubp
   364 000004EE D906[8200]          <1>     fld dword [p_y]
   365 000004F2 D906[5200]          <1>     fld dword [p0_y]
   366 000004F6 DEE9                <1>     fsubp
   367 000004F8 DEC9                <1>     fmulp
   368                              <1> 
   369 000004FA DEE9                <1>     fsubp
   370                              <1> 
   371                              <1>     
   372 000004FC DF16[9600]          <1>     fist word [area_sign_int_2]
   373 00000500 D91E[8E00]          <1>     fstp dword [area_sign_2]
   374                              <1> 
   375 00000504 833E[9600]00        <1>     cmp word [area_sign_int_2], 0
   376 00000509 7C04                <1>     jl .negative
   377 0000050B B80100              <1>     mov ax, 1
   378 0000050E C3                  <1>     ret
   379                              <1>     .negative:
   380 0000050F B80000              <1>     mov ax, 0
   381 00000512 C3                  <1>     ret
   382                              <1> calc_signed_area_2_end:
   383                              <1> 
   384                              <1> 
   385                              <1> 
   386                              <1> ;--- transform_triangle_1_into_current ---------
   387                              <1> ; 
   388                              <1> ;   Applies transformations and move into 'current' points
   389                              <1> ;   
   390                              <1> transform_triangle_1_into_current:
   391 00000513 55                  <1>     push bp
   392 00000514 89E5                <1>     mov bp, sp
   393                              <1> 
   394                              <1>     ; 1. Move triangle_1 points to current triangle
   395                              <1>     ; 2. apply position transformation
   396                              <1>  
   397                              <1>     ; point 0
   398                              <1>     ; x
   399 00000516 D906[8602]          <1>     fld dword [triangle_1+0]
   400 0000051A D906[6E02]          <1>     fld dword [position + 0]
   401 0000051E DEC1                <1>     faddp
   402                              <1>     ; fistp word [current_triangle_pixels+0]
   403                              <1>     ; fstp dword [current_triangle + 0]
   404                              <1>     ; fstp dword [current_triangle + 0]
   405 00000520 DF16[6600]          <1>     fist word [p0_x_int]
   406 00000524 D91E[4E00]          <1>     fstp dword [p0_x]
   407                              <1>     ; y
   408 00000528 D906[8A02]          <1>     fld dword [triangle_1+4]
   409 0000052C D906[7202]          <1>     fld dword [position + 4]
   410 00000530 DEC1                <1>     faddp
   411                              <1>     ; fistp word [current_triangle_pixels+2]
   412                              <1>     ; fstp dword [current_triangle + 4]
   413 00000532 DF16[6800]          <1>     fist word [p0_y_int]
   414 00000536 D91E[5200]          <1>     fstp dword [p0_y]
   415                              <1> 
   416                              <1>     ; point 1
   417                              <1> 
   418 0000053A D906[9202]          <1>     fld dword [triangle_1+12]
   419 0000053E D906[6E02]          <1>     fld dword [position + 0]
   420 00000542 DEC1                <1>     faddp
   421                              <1>     ; fistp word [current_triangle_pixels+4]
   422                              <1>     ; fstp dword [current_triangle + 12]
   423 00000544 DF16[6A00]          <1>     fist word [p1_x_int]
   424 00000548 D91E[5600]          <1>     fstp dword [p1_x]
   425                              <1> 
   426 0000054C D906[9602]          <1>     fld dword [triangle_1+16]
   427 00000550 D906[7202]          <1>     fld dword [position + 4]
   428 00000554 DEC1                <1>     faddp
   429                              <1>     ; fistp word [current_triangle_pixels+6]
   430                              <1>     ; fstp dword [current_triangle + 16]
   431 00000556 DF16[6C00]          <1>     fist word [p1_y_int]
   432 0000055A D91E[5A00]          <1>     fstp dword [p1_y]
   433                              <1> 
   434                              <1>     ; point 2
   435 0000055E D906[9E02]          <1>     fld dword [triangle_1+24]
   436 00000562 D906[6E02]          <1>     fld dword [position + 0]
   437 00000566 DEC1                <1>     faddp
   438                              <1>     ; fistp word [current_triangle_pixels+8]
   439                              <1>     ; fstp dword [current_triangle + 24]
   440 00000568 DF16[6E00]          <1>     fist word [p2_x_int]
   441 0000056C D91E[5E00]          <1>     fstp dword [p2_x]
   442                              <1> 
   443 00000570 D906[A202]          <1>     fld dword [triangle_1+28]
   444 00000574 D906[7202]          <1>     fld dword [position + 4]
   445 00000578 DEC1                <1>     faddp
   446                              <1>     ; fistp word [current_triangle_pixels+10]
   447                              <1>     ; fstp dword [current_triangle + 28]
   448 0000057A DF16[7000]          <1>     fist word [p2_y_int]
   449 0000057E D91E[6200]          <1>     fstp dword [p2_y]
   450                              <1> 
   451                              <1>     ; call draw_current_triangle_points
   452                              <1> 
   453                              <1> 
   454 00000582 89EC                <1>     mov sp, bp
   455 00000584 5D                  <1>     pop bp
   456 00000585 C3                  <1>     ret
   457                              <1> transform_triangle_1_into_current_end:
   458                              <1> 
   459                              <1> 
   460                              <1> 
   461                              <1> current_triangle_into_pixel_coord:
   462 00000586 55                  <1>     push bp
   463 00000587 89E5                <1>     mov bp, sp
   464                              <1> 
   465                              <1>     ; 1. Move current triangle points to pixel coordinates
   466                              <1>  
   467                              <1>     ; point 0
   468                              <1>     ; x
   469 00000589 D906[4E00]          <1>     fld dword [p0_x]
   470 0000058D DF1E[2A00]          <1>     fistp word [current_triangle_pixels+0]
   471                              <1>     ; y
   472 00000591 D906[5200]          <1>     fld dword [p0_y]
   473 00000595 DF1E[2C00]          <1>     fistp word [current_triangle_pixels+2]
   474                              <1> 
   475                              <1>     ; point 1
   476                              <1>     ; x
   477 00000599 D906[5600]          <1>     fld dword [p1_x]
   478 0000059D DF1E[2E00]          <1>     fistp word [current_triangle_pixels+4]
   479                              <1>     ; y
   480 000005A1 D906[5A00]          <1>     fld dword [p1_y]
   481 000005A5 DF1E[3000]          <1>     fistp word [current_triangle_pixels+6]
   482                              <1> 
   483                              <1>     ; point 2
   484                              <1>     ; x
   485 000005A9 D906[5E00]          <1>     fld dword [p2_x]
   486 000005AD DF1E[3200]          <1>     fistp word [current_triangle_pixels+8]
   487                              <1>     ; y
   488 000005B1 D906[6200]          <1>     fld dword [p2_y]
   489 000005B5 DF1E[3400]          <1>     fistp word [current_triangle_pixels+10]
   490                              <1> 
   491                              <1>     ; call draw_current_triangle
   492                              <1> 
   493 000005B9 89EC                <1>     mov sp, bp
   494 000005BB 5D                  <1>     pop bp
   495 000005BC C3                  <1>     ret
   496                              <1> current_triangle_into_pixel_coord_end:
   497                              <1> 
   498                              <1> 
   499                              <1> 
   500                              <1> draw_current_triangle_points:
   501 000005BD BE[2A00]            <1>     mov si, current_triangle_pixels
   502                              <1> 
   503 000005C0 8B04                <1>     mov ax, [si+0]
   504 000005C2 8B5C02              <1>     mov bx, [si+2]
   505 000005C5 E8CD01              <1>     call pixel_xa_yb
   506                              <1> 
   507 000005C8 8B4404              <1>     mov ax, [si+4]
   508 000005CB 8B5C06              <1>     mov bx, [si+6]
   509 000005CE E8C401              <1>     call pixel_xa_yb
   510                              <1> 
   511 000005D1 8B4408              <1>     mov ax, [si+8]
   512 000005D4 8B5C0A              <1>     mov bx, [si+10]
   513 000005D7 E8BB01              <1>     call pixel_xa_yb
   514                              <1> 
   515 000005DA C3                  <1>     ret
   516                              <1> draw_current_triangle_points_end:
   517                              <1> 
   518                              <1> 
   519                              <1> 
   520                              <1> 
   521                              <1> ;--- draw_sine ---------
   522                              <1> ; 
   523                              <1> ;   Loops through integers in range [0, SCREEN_WIDTH].
   524                              <1> ;   Maps each x-coord to sine function.
   525                              <1> ;   Will print the y-coord
   526                              <1> draw_sine:
   527 000005DB 55                  <1>     push bp
   528 000005DC 89E5                <1>     mov bp, sp
   529                              <1> 
   530                              <1>     ; Local vars
   531 000005DE 83EC02              <1>     sub sp, 2 ; x = [bp - 2]
   532 000005E1 83EC02              <1>     sub sp, 2 ; y = [bp - 4]
   533 000005E4 C746FE0000          <1>     mov word [bp - 2], 0
   534                              <1> 
   535 000005E9 83EC02              <1>     sub sp, 2 ; A = [bp - 6]
   536 000005EC 83EC02              <1>     sub sp, 2 ; V = [bp - 8]
   537 000005EF 83EC02              <1>     sub sp, 2 ; c = [bp - 10]
   538 000005F2 C746FA1400          <1>     mov word [bp - 6], 20
   539 000005F7 C746F86400          <1>     mov word [bp - 8], 100
   540 000005FC C746F60A00          <1>     mov word [bp - 10], 10
   541                              <1>     
   542                              <1>     ; Loop through all x-coords
   543                              <1>     .next_x:
   544                              <1> 
   545                              <1>     ;-------------------------
   546                              <1>     ;   Sine curve
   547                              <1>     ;   f(x) =  V + A*sin(x/c)
   548                              <1>     ;   RPN:    V A x c / sin * +
   549                              <1>     ;------------------------]
   550 00000601 DF46F8              <1>     fild word [bp - 8]  ; V
   551 00000604 DF46FA              <1>     fild word [bp - 6]  ; A
   552 00000607 DF46FE              <1>     fild word [bp - 2]  ; x
   553 0000060A DF46F6              <1>     fild word [bp - 10] ; c
   554 0000060D DEF9                <1>     fdivp
   555 0000060F D9FE                <1>     fsin
   556 00000611 DEC9                <1>     fmulp
   557 00000613 DEC1                <1>     faddp
   558                              <1> 
   559 00000615 DF5EFC              <1>     fistp word [bp - 4] ; y
   560                              <1>     
   561                              <1>     ; Draw pixel
   562 00000618 8B46FE              <1>     mov ax, word [bp - 2]
   563 0000061B 8B5EFC              <1>     mov bx, word [bp - 4]
   564 0000061E E87401              <1>     call pixel_xa_yb
   565                              <1> 
   566                              <1> 
   567 00000621 FF46FE              <1>     inc word [bp - 2]
   568 00000624 817EFE4001          <1>     cmp word [bp - 2], 320
   569 00000629 72D6                <1>     jb .next_x
   570                              <1> 
   571 0000062B 89EC                <1>     mov sp, bp
   572 0000062D 5D                  <1>     pop bp
   573 0000062E C3                  <1>     ret
   574                              <1> draw_sine_end:
   575                              <1>     
   576                              <1> ; First attempt to reduce flickering by swapping
   577                              <1> swap_buffer:
   578                              <1>     ; pusha
   579                              <1> 
   580                              <1>     ; fsqrt
   581                              <1> 
   582                              <1>     ; draw six pixels to second buffer
   583 0000062F B80070              <1>     mov ax, 0x7000
   584 00000632 8EC0                <1>     mov es, ax
   585 00000634 BF8202              <1>     mov di, 642
   586 00000637 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   587 0000063C BF8402              <1>     mov di, 644
   588 0000063F 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   589 00000644 BF8602              <1>     mov di, 646
   590 00000647 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   591 0000064C BF8802              <1>     mov di, 648
   592 0000064F 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   593 00000654 BF8A02              <1>     mov di, 650
   594 00000657 26C7050F0F          <1>     mov word [es:di], 0x0F0F
   595                              <1> 
   596                              <1>     ; cli
   597 0000065C 1E                  <1>     push ds
   598                              <1> 
   599 0000065D E82200              <1>     call wait_for_vsync
   600                              <1>     
   601 00000660 B80070              <1>     mov ax, 0x7000
   602 00000663 8EC0                <1>     mov es, ax
   603                              <1> 
   604 00000665 B800A0              <1>     mov ax, 0xA000
   605 00000668 8ED8                <1>     mov ds, ax
   606                              <1> 
   607 0000066A 31FF                <1>     xor di, di
   608 0000066C 31F6                <1>     xor si, si
   609 0000066E B900FA              <1>     mov cx, 64000
   610 00000671 BA00FA              <1>     mov dx, 64000
   611                              <1>     ; xor cx, cx
   612                              <1>     ; xor si, si
   613                              <1>     .loop_1:
   614                              <1> 
   615 00000674 268A04              <1>     mov al, byte [es:si]
   616 00000677 3E8805              <1>     mov byte [ds:di], al
   617                              <1> 
   618                              <1>     ; rep movsw
   619 0000067A 46                  <1>     inc si
   620 0000067B 47                  <1>     inc di
   621                              <1>     ; sli
   622 0000067C 39D6                <1>     cmp si, dx
   623 0000067E 72F4                <1>     jb .loop_1
   624                              <1>     ; DEBUG
   625                              <1>     ; cli
   626                              <1>     ; hlt
   627                              <1> 
   628 00000680 1F                  <1>     pop ds
   629                              <1> 
   630                              <1> 
   631                              <1> 
   632                              <1>     ; popa
   633 00000681 C3                  <1>     ret
   634                              <1> swap_buffer_end:
   635                              <1> 
   636                              <1> ; Attempt to avoid writing to framebuffer during render
   637                              <1> wait_for_vsync:
   638 00000682 BADA03              <1>     mov dx, 0x03DA     ; VGA input status register
   639                              <1> vsync_start:
   640 00000685 EC                  <1>     in al, dx          ; Read the status
   641 00000686 A808                <1>     test al, 0x08      ; Check vertical retrace bit (bit 3)
   642 00000688 74FB                <1>     jz vsync_start     ; Wait until retrace starts
   643                              <1> vsync_end:
   644 0000068A EC                  <1>     in al, dx
   645 0000068B A808                <1>     test al, 0x08
   646 0000068D 75FB                <1>     jnz vsync_end      ; Wait until retrace ends
   647 0000068F C3                  <1>     ret
   648                              <1> 
   649                              <1> ; Draws a triangle outline based on the 'tri_2d_int_array' array
   650                              <1> ;
   651                              <1> ; No inputs nor outputs; only reading the fixed data array
   652                              <1> draw_triangle:
   653                              <1>     ; pusha
   654 00000690 55                  <1>     push bp
   655 00000691 89E5                <1>     mov bp, sp
   656                              <1> 
   657                              <1>     ; P1 : Upper left corner
   658 00000693 8B1E[0200]          <1>     mov bx, word [tri_2d_int_array+2]    ; y
   659 00000697 A1[0000]            <1>     mov ax, word [tri_2d_int_array+0]    ; x
   660 0000069A E8F800              <1>     call pixel_xa_yb
   661                              <1>     ; add sp, 6
   662                              <1> 
   663                              <1>     ; P2 : top right corner
   664 0000069D 8B1E[0800]          <1>     mov bx, word [tri_2d_int_array+8]    ; y
   665 000006A1 A1[0600]            <1>     mov ax, word [tri_2d_int_array+6]    ; x
   666 000006A4 E8EE00              <1>     call pixel_xa_yb
   667                              <1> 
   668                              <1>     ; P3 : Bottom left corner
   669 000006A7 8B1E[0E00]          <1>     mov bx, word [tri_2d_int_array+14]    ; y
   670 000006AB A1[0C00]            <1>     mov ax, word [tri_2d_int_array+12]    ; x
   671 000006AE E8E400              <1>     call pixel_xa_yb
   672                              <1> 
   673                              <1> 
   674                              <1>     ;
   675                              <1>     ; Draw line from point 1 to point 2
   676                              <1>     ;
   677 000006B1 FF36[0800]          <1>     push word [tri_2d_int_array+8] ; y_1
   678 000006B5 FF36[0600]          <1>     push word [tri_2d_int_array+6] ; x_1
   679 000006B9 FF36[0200]          <1>     push word [tri_2d_int_array+2] ; y_0
   680 000006BD FF36[0000]          <1>     push word [tri_2d_int_array+0] ; x_0
   681 000006C1 E87A00              <1>     call draw_line
   682 000006C4 83C408              <1>     add sp, 8
   683 000006C7 DDC1                <1>     ffree st1
   684                              <1>     ;
   685                              <1>     ; Draw line from point 1 to point 3
   686                              <1>     ;
   687 000006C9 FF36[0E00]          <1>     push word [tri_2d_int_array+14] ; y_1
   688 000006CD FF36[0C00]          <1>     push word [tri_2d_int_array+12] ; x_1
   689 000006D1 FF36[0200]          <1>     push word [tri_2d_int_array+2] ; y_0
   690 000006D5 FF36[0000]          <1>     push word [tri_2d_int_array+0] ; x_0
   691 000006D9 E86200              <1>     call draw_line
   692 000006DC 83C408              <1>     add sp, 8
   693                              <1> 
   694                              <1>     ;
   695                              <1>     ; Draw line from point 3 to point 2
   696                              <1>     ;
   697                              <1> 
   698                              <1> 
   699                              <1>     ; DELTAS
   700                              <1>     ;
   701                              <1>     ; delta x
   702 000006DF A1[0600]            <1>     mov ax, [tri_2d_int_array+6]
   703 000006E2 2B06[0C00]          <1>     sub ax, [tri_2d_int_array+12]
   704                              <1>     ; delta y
   705 000006E6 8B1E[0800]          <1>     mov bx, [tri_2d_int_array+8]
   706 000006EA 2B1E[0E00]          <1>     sub bx, [tri_2d_int_array+14]
   707                              <1> 
   708                              <1>     ; Add delta as constants for the rest of point 3 to point 2
   709 000006EE 50                  <1>     push ax
   710 000006EF 53                  <1>     push bx
   711                              <1>     
   712                              <1> 
   713                              <1>     ; SLOPE
   714                              <1>     ;
   715 000006F0 8B46FE              <1>     mov ax, word [bp - 2]
   716 000006F3 8B5EFC              <1>     mov bx, word [bp - 4]
   717 000006F6 E8BF00              <1>     call slope_100
   718                              <1>     ; slope returned in dx
   719 000006F9 52                  <1>     push dx ; persist the slope100
   720 000006FA 8B7EFA              <1>     mov di, [bp - 6]
   721                              <1> 
   722                              <1>     ; print slope
   723 000006FD 50                  <1>     push ax
   724 000006FE 89D0                <1>     mov ax, dx
   725 00000700 E84B01              <1>     call print_hex_value
   726 00000703 58                  <1>     pop ax
   727                              <1>     ; draw points between point 3 and 2
   728                              <1>     ; starting at point 3
   729                              <1> 
   730                              <1>     ; push ax ; delta x
   731                              <1> 
   732 00000704 B90000              <1>     mov cx, 0; x index
   733                              <1>     .line_next_step:
   734 00000707 41                  <1>     inc cx
   735                              <1>     
   736                              <1>     ; starting values
   737 00000708 A1[0C00]            <1>     mov ax, word [tri_2d_int_array+12] ; x
   738 0000070B 8B1E[0E00]          <1>     mov bx, word [tri_2d_int_array+14] ; y
   739                              <1> 
   740                              <1>     ; increment x coord
   741 0000070F 01C8                <1>     add ax, cx
   742                              <1> 
   743                              <1>     ; multiply x offset by slope
   744 00000711 51                  <1>     push cx ; [pb - 8] = x offset from origin point
   745 00000712 DF46F8              <1>     fild word [bp - 8]
   746 00000715 DF46FA              <1>     fild word [bp - 6] ; slope100
   747 00000718 DEC9                <1>     fmul
   748 0000071A 83C402              <1>     add sp, 2 ; remove x offset
   749 0000071D 6A64                <1>     push word 100 ; [pb - 8] = slope multiplier
   750 0000071F DF46F8              <1>     fild word [bp - 8]
   751 00000722 DEF9                <1>     fdiv
   752 00000724 DF5EF8              <1>     fistp word [bp - 8]
   753 00000727 8B56F8              <1>     mov dx, word [bp - 8]
   754 0000072A 83C402              <1>     add sp, 2     ; clear slope multiplier
   755                              <1> 
   756                              <1> 
   757                              <1> 
   758 0000072D 01D3                <1>     add bx, dx
   759                              <1> 
   760 0000072F E86300              <1>     call pixel_xa_yb
   761                              <1> 
   762 00000732 3B4EFE              <1>     cmp cx, [bp - 2]
   763 00000735 7ED0                <1>     jle .line_next_step
   764                              <1> 
   765                              <1>     
   766                              <1>     
   767 00000737 83C406              <1>     add sp, 6
   768                              <1> 
   769                              <1>     
   770                              <1> 
   771 0000073A 89EC                <1>     mov sp, bp
   772 0000073C 5D                  <1>     pop bp
   773                              <1>     ; popa
   774 0000073D C3                  <1>     ret
   775                              <1> draw_triangle_end:
   776                              <1> 
   777                              <1> 
   778                              <1> 
   779                              <1> ;   fn: DRAW_LINE
   780                              <1> ;
   781                              <1> ;   y_1 = bp + 10
   782                              <1> ;   x_1 = bp + 8
   783                              <1> ;   y_0 = bp + 6
   784                              <1> ;   x_0 = bp + 4
   785                              <1> ;
   786                              <1> draw_line:
   787 0000073E 55                  <1>     push bp
   788 0000073F 89E5                <1>     mov bp, sp
   789                              <1> 
   790                              <1>     ; DELTAS
   791                              <1>     ;
   792                              <1>     ; delta x
   793 00000741 8B4608              <1>     mov ax, [bp + 8]
   794 00000744 2B4604              <1>     sub ax, [bp + 4]
   795                              <1>     ; delta y
   796 00000747 8B5E0A              <1>     mov bx, [bp + 10]
   797 0000074A 2B5E06              <1>     sub bx, [bp + 6]
   798                              <1> 
   799                              <1>     ; Add delta as constants for the rest of point 3 to point 2
   800 0000074D 50                  <1>     push ax
   801 0000074E 53                  <1>     push bx
   802                              <1>     
   803                              <1> 
   804                              <1>     ; SLOPE
   805                              <1>     ;
   806 0000074F 8B46FE              <1>     mov ax, word [bp - 2]
   807 00000752 8B5EFC              <1>     mov bx, word [bp - 4]
   808 00000755 E86000              <1>     call slope_100
   809                              <1>     ; slope returned in dx
   810 00000758 52                  <1>     push dx ; persist the slope100
   811 00000759 8B7EFA              <1>     mov di, [bp - 6]
   812                              <1> 
   813                              <1>     ; print slope
   814                              <1>     ; push ax
   815                              <1>     ; mov ax, dx
   816                              <1>     ; call print_hex_value
   817                              <1>     ; pop ax
   818                              <1>     ; draw points between point 3 and 2
   819                              <1>     ; starting at point 3
   820                              <1> 
   821                              <1>     ; push ax ; delta x
   822                              <1> 
   823 0000075C B90000              <1>     mov cx, 0; x index
   824                              <1>     .line_next_step:
   825 0000075F 41                  <1>     inc cx
   826                              <1>     
   827                              <1>     ; starting values
   828 00000760 8B4604              <1>     mov ax, word [bp + 4] ; x
   829 00000763 8B5E06              <1>     mov bx, word [bp + 6] ; y
   830                              <1> 
   831                              <1>     ; increment x coord
   832 00000766 01C8                <1>     add ax, cx
   833                              <1> 
   834                              <1>     ; multiply x offset by slope
   835 00000768 51                  <1>     push cx ; [pb - 8] = x offset from origin point
   836 00000769 DF46F8              <1>     fild word [bp - 8]
   837 0000076C DF46FA              <1>     fild word [bp - 6] ; slope100
   838 0000076F DEC9                <1>     fmul
   839 00000771 83C402              <1>     add sp, 2 ; remove x offset
   840 00000774 6A64                <1>     push word 100 ; [pb - 8] = slope multiplier
   841 00000776 DF46F8              <1>     fild word [bp - 8]
   842 00000779 DEF9                <1>     fdiv
   843 0000077B DF5EF8              <1>     fistp word [bp - 8]
   844 0000077E 8B56F8              <1>     mov dx, word [bp - 8]
   845 00000781 83C402              <1>     add sp, 2     ; clear slope multiplier
   846                              <1> 
   847                              <1> 
   848                              <1> 
   849 00000784 01D3                <1>     add bx, dx
   850                              <1> 
   851 00000786 E80C00              <1>     call pixel_xa_yb
   852                              <1> 
   853 00000789 3B4EFE              <1>     cmp cx, [bp - 2]
   854 0000078C 7ED1                <1>     jle .line_next_step
   855                              <1> 
   856                              <1>     
   857                              <1>     
   858 0000078E 83C406              <1>     add sp, 6
   859                              <1> 
   860 00000791 89EC                <1>     mov sp, bp
   861 00000793 5D                  <1>     pop bp
   862 00000794 C3                  <1>     ret
   863                              <1> 
   864                              <1> draw_line_end:
   865                              <1> 
   866                              <1> 
   867                              <1> 
   868                              <1> ; fn: PIXEL_XA_YB
   869                              <1> ;
   870                              <1> ; Draws pixel WITHOUT register or stack side effects.
   871                              <1> ; Color: white
   872                              <1> ; Coordinate system: right handed with origin botton left
   873                              <1> ; input:
   874                              <1> ;       ax : x location
   875                              <1> ;       bx : y location
   876                              <1> pixel_xa_yb:
   877 00000795 51                  <1>     push cx ; x index
   878 00000796 52                  <1>     push dx ; y index
   879 00000797 06                  <1>     push es ; video memory segment
   880 00000798 57                  <1>     push di ; offset
   881                              <1> 
   882 00000799 B90070              <1>     mov cx, VIDEO_D_BUFFER ; cx is a temp leave ax/bx untouched
   883 0000079C 8EC1                <1>     mov es, cx
   884 0000079E 31C9                <1>     xor cx, cx
   885                              <1> 
   886 000007A0 BAC800              <1>     mov dx, 200
   887 000007A3 29DA                <1>     sub dx, bx
   888                              <1> 
   889 000007A5 89C1                <1>     mov cx, ax
   890                              <1> 
   891 000007A7 BF4001              <1>     mov di, 320
   892 000007AA 0FAFFA              <1>     imul di, dx
   893 000007AD 01CF                <1>     add di, cx
   894                              <1> 
   895 000007AF 26C6050F            <1>     mov byte [es:di], 0x0F
   896                              <1>     
   897 000007B3 5F                  <1>     pop di
   898 000007B4 07                  <1>     pop es
   899 000007B5 5A                  <1>     pop dx
   900 000007B6 59                  <1>     pop cx
   901 000007B7 C3                  <1>     ret
   902                              <1> pixel_xa_yb_end:
   903                              <1> 
   904                              <1> 
   905                              <1> 
   906                              <1> 
   907                              <1> 
   908                              <1> ; fn    :   Returns the slope of the delta x & y.
   909                              <1> ; in    :   ax = delta x
   910                              <1> ;           bx = delta y
   911                              <1> ; ret   :   dx = slope * 100 (dy/dx*100)
   912                              <1> ; modreg:   
   913                              <1> slope_100:
   914 000007B8 55                  <1>     push bp
   915 000007B9 89E5                <1>     mov bp, sp
   916                              <1> 
   917 000007BB 50                  <1>     push ax     ; delta x
   918 000007BC 53                  <1>     push bx     ; delta y
   919 000007BD 6A64                <1>     push word 100
   920 000007BF 83EC02              <1>     sub sp, 2   ; slope integer
   921                              <1> 
   922 000007C2 DF46FC              <1>     fild word [bp - 4] ; dy = ST 1
   923 000007C5 DF46FE              <1>     fild word [bp - 2] ; dx = ST 0
   924                              <1> 
   925 000007C8 DEF9                <1>     fdiv  ; ST(0) = ST(1) / ST(0) ?
   926                              <1> 
   927 000007CA DF46FA              <1>     fild word [bp - 6] ; 100 multiplier
   928                              <1> 
   929 000007CD DEC9                <1>     fmul
   930                              <1> 
   931                              <1>     ; fistp dword [slope_float]     ; Convert and pop ST(0)
   932                              <1> 
   933                              <1>     ; pop into memory, then into ax for resturn
   934 000007CF DF5EF8              <1>     fistp word [bp - 8]
   935 000007D2 8B56F8              <1>     mov dx, word [bp - 8]   
   936                              <1> 
   937                              <1>     
   938 000007D5 83C402              <1>     add sp, 2 ;reset local variable
   939 000007D8 83C402              <1>     add sp, 2 ;
   940 000007DB 5B                  <1>     pop bx ; delta y
   941 000007DC 58                  <1>     pop ax ; delta x
   942                              <1> 
   943 000007DD 89EC                <1>     mov sp, bp
   944 000007DF 5D                  <1>     pop bp
   945 000007E0 C3                  <1>     ret
   946                              <1> slope_100_end:
   947                              <1> 
   948                              <1> ; fn    :   Returns the slope of the delta x & y.
   949                              <1> ; in    :   ax = delta x
   950                              <1> ;           bx = delta y
   951                              <1> ; ret   :   si = slope * 100 (dy/dx*100)
   952                              <1> ; modreg:   
   953                              <1> slope_calc_100_old_int:
   954 000007E1 51                  <1>     push cx
   955 000007E2 52                  <1>     push dx
   956                              <1> 
   957 000007E3 BE0000              <1>     mov si, 0x0000
   958 000007E6 89DA                <1>         mov dx, bx
   959 000007E8 6BD264              <1>         imul dx, 100
   960                              <1>         ; count number of dx in dy*100
   961 000007EB B90000              <1>         mov cx, 0
   962                              <1>     .slope_calc_loop:
   963 000007EE 01C1                <1>         add cx, ax
   964 000007F0 46                  <1>         inc si
   965 000007F1 39D1                <1>         cmp cx, dx
   966 000007F3 7EF9                <1>         jle .slope_calc_loop
   967                              <1>     .slope_calc_loop_end:
   968                              <1> 
   969 000007F5 5A                  <1>     pop dx
   970 000007F6 59                  <1>     pop cx
   971 000007F7 C3                  <1>     ret
   972                              <1> slope_calc_100_old_int_end:
   973                              <1> 
   974                              <1> 
   975                              <1> 
   976                              <1> show_current_ascii_press:
   977 000007F8 833E[4602]00        <1>     cmp word [ascii_current_press], 0
   978 000007FD 740C                <1>     je .write_current_press_end
   979 000007FF A1[4602]            <1>     mov ax, word [ascii_current_press]
   980 00000802 E84802              <1>     call write_ascii_char_at_cursor
   981 00000805 C706[4602]0000      <1>     mov word [ascii_current_press], 0 ; reset current press value as it is acting as press-flag
   982                              <1>     .write_current_press_end:
   983 0000080B C3                  <1>     ret
   984                              <1> 
   985                              <1> 
   986                              <1> a2x2_cluster:
   987 0000080C 6A00                <1>     push 0x00   ; color
   988 0000080E 6A69                <1>     push  105    ; y
   989 00000810 6A69                <1>     push  105    ; x
   990 00000812 E83403              <1>     call draw_2x2
   991 00000815 83C406              <1>     add sp, 6
   992                              <1> 
   993 00000818 6A00                <1>     push 0x00   ; color
   994 0000081A 6A67                <1>     push  103    ; y
   995 0000081C 6A65                <1>     push  101    ; x
   996 0000081E E82803              <1>     call draw_2x2
   997 00000821 83C406              <1>     add sp, 6
   998                              <1> 
   999 00000824 6A00                <1>     push 0x00   ; color
  1000 00000826 6A65                <1>     push  101    ; y
  1001 00000828 6A68                <1>     push  104    ; x
  1002 0000082A E81C03              <1>     call draw_2x2
  1003 0000082D 83C406              <1>     add sp, 6
  1004                              <1> 
  1005 00000830 6A00                <1>     push 0x00   ; color
  1006 00000832 6A64                <1>     push 100    ; y
  1007 00000834 6A64                <1>     push 100    ; x
  1008 00000836 E81003              <1>     call draw_2x2
  1009 00000839 83C406              <1>     add sp, 6
  1010                              <1> 
  1011 0000083C C3                  <1>     ret
  1012                              <1> 
  1013                              <1> draw_player_position:
  1014 0000083D 6A02                <1>     push 0x02   ; color
  1015 0000083F FF36[6602]          <1>     push word [player_position_y]    ; y
  1016 00000843 FF36[6402]          <1>     push word [player_position_x]    ; x
  1017 00000847 E8FF02              <1>     call draw_2x2
  1018 0000084A 83C406              <1>     add sp, 6
  1019 0000084D C3                  <1>     ret
  1020                              <1> 
  1021                              <1> 
  1022                              <1> ; fn: prints the 16-bit value as hex number in screen low right corner
  1023                              <1> ; in: ax = word-width value to print
  1024                              <1> print_hex_value:
  1025 0000084E 55                  <1>     push bp
  1026 0000084F 89E5                <1>     mov bp, sp
  1027                              <1> 
  1028                              <1>     ; Store the original value to be printed
  1029 00000851 50                  <1>     push ax
  1030                              <1> 
  1031                              <1> 
  1032                              <1>     ; word_l, low nibble
  1033 00000852 8B76FE              <1>     mov si, [bp - 2]
  1034 00000855 C1E60C              <1>     shl si, 12
  1035 00000858 C1EE0C              <1>     shr si, 12
  1036 0000085B 8A9C[9800]          <1>     mov bl, byte [hex_print_table + si]
  1037 0000085F 30FF                <1>     xor bh, bh
  1038                              <1> 
  1039 00000861 89D8                <1>     mov ax, bx
  1040 00000863 E80602              <1>     call char_ascii_to_bitmap_address
  1041 00000866 50                  <1>     push ax             ; char address
  1042 00000867 68BE00              <1>     push 190            ; y
  1043 0000086A 683601              <1>     push 310             ; x
  1044 0000086D E8A502              <1>     call write_char_from_bitmap_address
  1045 00000870 83C406              <1>     add sp, 6
  1046                              <1> 
  1047                              <1> 
  1048                              <1>     ; word_l, high nibble
  1049 00000873 8B76FE              <1>     mov si, [bp - 2]
  1050 00000876 C1E608              <1>     shl si, 8
  1051 00000879 C1EE0C              <1>     shr si, 12
  1052 0000087C 8A9C[9800]          <1>     mov bl, byte [hex_print_table + si]
  1053 00000880 30FF                <1>     xor bh, bh
  1054                              <1> 
  1055 00000882 89D8                <1>     mov ax, bx
  1056 00000884 E8E501              <1>     call char_ascii_to_bitmap_address
  1057 00000887 50                  <1>     push ax             ; char address
  1058 00000888 68BE00              <1>     push 190            ; y
  1059 0000088B 682C01              <1>     push 300             ; x
  1060 0000088E E88402              <1>     call write_char_from_bitmap_address
  1061 00000891 83C406              <1>     add sp, 6
  1062                              <1> 
  1063                              <1>     ; word_h, low nibble
  1064 00000894 8B76FE              <1>     mov si, [bp - 2]
  1065 00000897 C1E604              <1>     shl si, 4
  1066 0000089A C1EE0C              <1>     shr si, 12
  1067 0000089D 8A9C[9800]          <1>     mov bl, byte [hex_print_table + si]
  1068 000008A1 30FF                <1>     xor bh, bh
  1069                              <1> 
  1070 000008A3 89D8                <1>     mov ax, bx
  1071 000008A5 E8C401              <1>     call char_ascii_to_bitmap_address
  1072 000008A8 50                  <1>     push ax             ; char address
  1073 000008A9 68BE00              <1>     push 190            ; y
  1074 000008AC 682201              <1>     push 290             ; x
  1075 000008AF E86302              <1>     call write_char_from_bitmap_address
  1076 000008B2 83C406              <1>     add sp, 6
  1077                              <1> 
  1078                              <1>     ; word_h, high nibble
  1079 000008B5 8B76FE              <1>     mov si, [bp - 2]
  1080 000008B8 C1E600              <1>     shl si, 0
  1081 000008BB C1EE0C              <1>     shr si, 12
  1082 000008BE 8A9C[9800]          <1>     mov bl, byte [hex_print_table + si]
  1083 000008C2 30FF                <1>     xor bh, bh
  1084                              <1> 
  1085 000008C4 89D8                <1>     mov ax, bx
  1086 000008C6 E8A301              <1>     call char_ascii_to_bitmap_address
  1087 000008C9 50                  <1>     push ax             ; char address
  1088 000008CA 68BE00              <1>     push 190            ; y
  1089 000008CD 681801              <1>     push 280             ; x
  1090 000008D0 E84202              <1>     call write_char_from_bitmap_address
  1091 000008D3 83C406              <1>     add sp, 6
  1092                              <1> 
  1093                              <1> 
  1094 000008D6 58                  <1>     pop ax
  1095                              <1> 
  1096 000008D7 89EC                <1>     mov sp, bp
  1097 000008D9 5D                  <1>     pop bp
  1098 000008DA C3                  <1>     ret
  1099                              <1> print_hex_value_end:
  1100                              <1> 
  1101                              <1> 
  1102                              <1> 
  1103                              <1> print_available_chars:
  1104                              <1> 
  1105 000008DB B83000              <1>     mov ax, '0'
  1106 000008DE E88B01              <1>     call char_ascii_to_bitmap_address
  1107 000008E1 50                  <1>     push ax             ; char address
  1108 000008E2 68BE00              <1>     push 190            ; y
  1109 000008E5 6A0A                <1>     push 10             ; x
  1110 000008E7 E82B02              <1>     call write_char_from_bitmap_address
  1111 000008EA 83C406              <1>     add sp, 6
  1112                              <1> 
  1113                              <1> 
  1114 000008ED B83100              <1>     mov ax, '1'
  1115 000008F0 E87901              <1>     call char_ascii_to_bitmap_address
  1116 000008F3 50                  <1>     push ax          ; Letter address
  1117 000008F4 68BE00              <1>     push 190            ; y
  1118 000008F7 6A14                <1>     push 20             ; x
  1119 000008F9 E81902              <1>     call write_char_from_bitmap_address
  1120 000008FC 83C406              <1>     add sp, 6
  1121                              <1> 
  1122 000008FF B83200              <1>     mov ax, '2'
  1123 00000902 E86701              <1>     call char_ascii_to_bitmap_address
  1124 00000905 50                  <1>     push ax          ; Letter address
  1125 00000906 68BE00              <1>     push word 190           ; y
  1126 00000909 6A1E                <1>     push word 30            ; x
  1127 0000090B E80702              <1>     call write_char_from_bitmap_address
  1128 0000090E 83C406              <1>     add sp, 6
  1129                              <1> 
  1130 00000911 B83300              <1>     mov ax, '3'
  1131 00000914 E85501              <1>     call char_ascii_to_bitmap_address
  1132 00000917 50                  <1>     push ax          ; Letter address
  1133 00000918 68BE00              <1>     push 190            ; y
  1134 0000091B 6A28                <1>     push 40             ; x
  1135 0000091D E8F501              <1>     call write_char_from_bitmap_address
  1136 00000920 83C406              <1>     add sp, 6
  1137                              <1> 
  1138 00000923 B83400              <1>      mov ax, '4'
  1139 00000926 E84301              <1>     call char_ascii_to_bitmap_address
  1140 00000929 50                  <1>     push ax          ; Letter address
  1141 0000092A 68BE00              <1>     push 190            ; y
  1142 0000092D 6A28                <1>     push 40             ; x
  1143 0000092F E8E301              <1>     call write_char_from_bitmap_address
  1144 00000932 83C406              <1>     add sp, 6
  1145                              <1> 
  1146 00000935 B83500              <1>     mov ax, '5'
  1147 00000938 E83101              <1>     call char_ascii_to_bitmap_address
  1148 0000093B 50                  <1>     push ax          ; Letter address
  1149 0000093C 68BE00              <1>     push word 190           ; y
  1150 0000093F 6A32                <1>     push word 50            ; x
  1151 00000941 E8D101              <1>     call write_char_from_bitmap_address
  1152 00000944 83C406              <1>     add sp, 6
  1153                              <1> 
  1154 00000947 B83600              <1>     mov ax, '6'
  1155 0000094A E81F01              <1>     call char_ascii_to_bitmap_address
  1156 0000094D 50                  <1>     push ax          ; Letter address
  1157 0000094E 68BE00              <1>     push 190            ; y
  1158 00000951 6A3C                <1>     push 60             ; x
  1159 00000953 E8BF01              <1>     call write_char_from_bitmap_address
  1160 00000956 83C406              <1>     add sp, 6
  1161                              <1> 
  1162 00000959 B83600              <1>     mov ax, '6'
  1163 0000095C E80D01              <1>     call char_ascii_to_bitmap_address
  1164 0000095F 50                  <1>     push ax          ; Letter address
  1165 00000960 68BE00              <1>     push 190            ; y
  1166 00000963 6A46                <1>     push 70             ; x
  1167 00000965 E8AD01              <1>     call write_char_from_bitmap_address
  1168 00000968 83C406              <1>     add sp, 6
  1169                              <1> 
  1170 0000096B B83700              <1>      mov ax, '7'
  1171 0000096E E8FB00              <1>     call char_ascii_to_bitmap_address
  1172 00000971 50                  <1>     push ax          ; Letter address
  1173 00000972 68BE00              <1>     push 190            ; y
  1174 00000975 6A50                <1>     push 80             ; x
  1175 00000977 E89B01              <1>     call write_char_from_bitmap_address
  1176 0000097A 83C406              <1>     add sp, 6
  1177                              <1> 
  1178 0000097D B83800              <1>     mov ax, '8'
  1179 00000980 E8E900              <1>     call char_ascii_to_bitmap_address
  1180 00000983 50                  <1>     push ax          ; Letter address
  1181 00000984 68BE00              <1>     push word 190           ; y
  1182 00000987 6A5A                <1>     push word 90            ; x
  1183 00000989 E88901              <1>     call write_char_from_bitmap_address
  1184 0000098C 83C406              <1>     add sp, 6
  1185                              <1> 
  1186 0000098F B83900              <1>     mov ax, '9'
  1187 00000992 E8D700              <1>     call char_ascii_to_bitmap_address
  1188 00000995 50                  <1>     push ax          ; Letter address
  1189 00000996 68BE00              <1>     push 190            ; y
  1190 00000999 6A64                <1>     push 100             ; x
  1191 0000099B E87701              <1>     call write_char_from_bitmap_address
  1192 0000099E 83C406              <1>     add sp, 6
  1193                              <1> 
  1194                              <1> 
  1195 000009A1 B84100              <1>     mov ax, 'A'
  1196 000009A4 E8C500              <1>     call char_ascii_to_bitmap_address
  1197                              <1>     ; mov si, ax          ; Letter address
  1198 000009A7 50                  <1>     push ax          ; Letter address
  1199 000009A8 68BE00              <1>     push 190            ; y
  1200 000009AB 6A6E                <1>     push 110             ; x
  1201 000009AD E86501              <1>     call write_char_from_bitmap_address
  1202 000009B0 83C406              <1>     add sp, 6
  1203                              <1> 
  1204 000009B3 B84200              <1>     mov ax, 'B'
  1205 000009B6 E8B300              <1>     call char_ascii_to_bitmap_address
  1206                              <1>     ; mov si, char_B          ; Letter address
  1207 000009B9 50                  <1>     push ax          ; Letter address
  1208 000009BA 68BE00              <1>     push word 190           ; y
  1209 000009BD 6A78                <1>     push word 120            ; x
  1210 000009BF E85301              <1>     call write_char_from_bitmap_address
  1211 000009C2 83C406              <1>     add sp, 6
  1212                              <1> 
  1213 000009C5 B84300              <1>     mov ax, 'C'
  1214 000009C8 E8A100              <1>     call char_ascii_to_bitmap_address
  1215 000009CB BE[0801]            <1>     mov si, char_C      ; Letter address
  1216 000009CE 50                  <1>     push ax          ; Letter address
  1217 000009CF 68BE00              <1>     push 190            ; y
  1218 000009D2 688200              <1>     push 130             ; x
  1219 000009D5 E83D01              <1>     call write_char_from_bitmap_address
  1220 000009D8 83C406              <1>     add sp, 6
  1221                              <1> 
  1222 000009DB B84400              <1>      mov ax, 'D'
  1223 000009DE E88B00              <1>     call char_ascii_to_bitmap_address
  1224                              <1>     ; mov si, ax          ; Letter address
  1225 000009E1 50                  <1>     push ax          ; Letter address
  1226 000009E2 68BE00              <1>     push 190            ; y
  1227 000009E5 688C00              <1>     push 140             ; x
  1228 000009E8 E82A01              <1>     call write_char_from_bitmap_address
  1229 000009EB 83C406              <1>     add sp, 6
  1230                              <1> 
  1231 000009EE B84500              <1>     mov ax, 'E'
  1232 000009F1 E87800              <1>     call char_ascii_to_bitmap_address
  1233                              <1>     ; mov si, char_B          ; Letter address
  1234 000009F4 50                  <1>     push ax          ; Letter address
  1235 000009F5 68BE00              <1>     push word 190           ; y
  1236 000009F8 689600              <1>     push word 150            ; x
  1237 000009FB E81701              <1>     call write_char_from_bitmap_address
  1238 000009FE 83C406              <1>     add sp, 6
  1239                              <1> 
  1240 00000A01 B84600              <1>     mov ax, 'F'
  1241 00000A04 E86500              <1>     call char_ascii_to_bitmap_address
  1242 00000A07 BE[0801]            <1>     mov si, char_C      ; Letter address
  1243 00000A0A 50                  <1>     push ax          ; Letter address
  1244 00000A0B 68BE00              <1>     push 190            ; y
  1245 00000A0E 68A000              <1>     push 160             ; x
  1246 00000A11 E80101              <1>     call write_char_from_bitmap_address
  1247 00000A14 83C406              <1>     add sp, 6
  1248                              <1> 
  1249 00000A17 C3                  <1>     ret
  1250                              <1> 
  1251                              <1> ; loop throught the cursor buffer, printing output at fixed row (2?)
  1252                              <1> write_whole_cursor_buffer:
  1253                              <1> 
  1254 00000A18 BB[4601]            <1>     mov bx, cursor_buffer       ; buffer address
  1255                              <1>     ; Indexes
  1256 00000A1B 8B0E[4802]          <1>     mov cx, word [cursor_count] ; loop decrement - index
  1257 00000A1F BE0000              <1>     mov si, 0x0000              ; current char index in buffer
  1258                              <1>     .print_cursor_buffer:
  1259                              <1>     
  1260                              <1> 
  1261                              <1>     ; move char from buffer and get char address
  1262 00000A22 8A00                <1>     mov al, byte [bx + si]
  1263 00000A24 30E4                <1>     xor ah, ah
  1264 00000A26 E84300              <1>     call char_ascii_to_bitmap_address
  1265                              <1> 
  1266                              <1>     ; set cursor x location
  1267 00000A29 89F2                <1>     mov dx, si                  ; buffer index
  1268 00000A2B 0FAF16[4E02]        <1>     imul dx, word [cursor_w]    ; cursor width
  1269                              <1> 
  1270                              <1>     ; set cursor y location (fixed for now)
  1271 00000A30 BF1200              <1>     mov di, 18 ; second row
  1272 00000A33 0FAF3E[5002]        <1>     imul di, word [cursor_h]
  1273                              <1>     
  1274                              <1> 
  1275                              <1>     ; perists across call
  1276 00000A38 56                  <1>     push si
  1277 00000A39 51                  <1>     push cx
  1278                              <1> 
  1279 00000A3A 50                  <1>     push ax             ; char bitmap address
  1280 00000A3B 57                  <1>     push di             ; y
  1281 00000A3C 52                  <1>     push dx             ; x
  1282 00000A3D E8D500              <1>     call write_char_from_bitmap_address
  1283 00000A40 83C406              <1>     add sp, 6
  1284                              <1> 
  1285 00000A43 59                  <1>     pop cx
  1286 00000A44 5E                  <1>     pop si
  1287                              <1> 
  1288                              <1>     ; call 
  1289                              <1>     ; mov ax, word [ascii_current_press]
  1290                              <1>     ; call write_char_at_cursor
  1291                              <1> 
  1292 00000A45 46                  <1>     inc si
  1293 00000A46 49                  <1>     dec cx
  1294 00000A47 83F900              <1>     cmp word cx, 0
  1295 00000A4A 7FD6                <1>     jg .print_cursor_buffer
  1296                              <1>     ; loop .print_cursor_buffer
  1297                              <1> 
  1298                              <1>     ; DEBUG
  1299                              <1>     ; cli 
  1300                              <1>     ; hlt
  1301                              <1> 
  1302 00000A4C C3                  <1>     ret
  1303                              <1> 
  1304                              <1> 
  1305                              <1> ; input     : ax = char ascii value
  1306                              <1> ; WILL ONLY RENDER FOR NEXT FRAME ONE FRAME!
  1307                              <1> ; NO INCREMENT
  1308                              <1> write_ascii_char_at_cursor:
  1309                              <1>     ; mov ax, 'A'
  1310 00000A4D E81C00              <1>     call char_ascii_to_bitmap_address
  1311                              <1>     ; ax = bitmap address
  1312                              <1>     
  1313                              <1>     ; set cursor x location
  1314 00000A50 8B1E[4A02]          <1>     mov bx, word [cursor_c]
  1315                              <1>     ; inc word [cursor_c]
  1316 00000A54 0FAF1E[4E02]        <1>     imul bx, word [cursor_w]
  1317                              <1> 
  1318                              <1>     ; set cursor y location (fixed for now)
  1319 00000A59 8B16[4C02]          <1>     mov dx, word [cursor_r]
  1320 00000A5D 0FAF16[5002]        <1>     imul dx, word [cursor_h]
  1321                              <1> 
  1322                              <1>     ; mov si, ax          ; Letter address
  1323 00000A62 50                  <1>     push ax
  1324 00000A63 52                  <1>     push dx            ; y
  1325 00000A64 53                  <1>     push bx             ; x
  1326 00000A65 E8AD00              <1>     call write_char_from_bitmap_address
  1327 00000A68 83C406              <1>     add sp, 6
  1328                              <1> 
  1329 00000A6B C3                  <1>     ret
  1330                              <1> 
  1331                              <1> 
  1332                              <1> ; input     : ax = char ascii value
  1333                              <1> ; return    : ax = bitmap address
  1334                              <1> char_ascii_to_bitmap_address:
  1335                              <1> 
  1336 00000A6C 83F830              <1> .0: cmp ax, 0x30
  1337 00000A6F 7506                <1>     jne .1
  1338 00000A71 B8[A800]            <1>     mov ax, char_0
  1339 00000A74 E99D00              <1>     jmp .done
  1340                              <1> 
  1341 00000A77 83F831              <1> .1: cmp ax, 0x31
  1342 00000A7A 7506                <1>     jne .2
  1343 00000A7C B8[B000]            <1>     mov ax, char_1
  1344 00000A7F E99200              <1>     jmp .done
  1345                              <1> 
  1346 00000A82 83F832              <1> .2: cmp ax, 0x32
  1347 00000A85 7506                <1>     jne .3 
  1348 00000A87 B8[B800]            <1>     mov ax, char_2
  1349 00000A8A E98700              <1>     jmp .done
  1350                              <1> 
  1351 00000A8D 83F833              <1> .3: cmp ax, 0x33
  1352 00000A90 7505                <1>     jne .4 
  1353 00000A92 B8[C000]            <1>     mov ax, char_3
  1354 00000A95 EB7D                <1>     jmp .done
  1355                              <1> 
  1356 00000A97 83F834              <1> .4: cmp ax, 0x34
  1357 00000A9A 7505                <1>     jne .5 
  1358 00000A9C B8[C800]            <1>     mov ax, char_4
  1359 00000A9F EB73                <1>     jmp .done
  1360                              <1> 
  1361 00000AA1 83F835              <1> .5: cmp ax, 0x35
  1362 00000AA4 7505                <1>     jne .6
  1363 00000AA6 B8[D000]            <1>     mov ax, char_5
  1364 00000AA9 EB69                <1>     jmp .done
  1365                              <1> 
  1366 00000AAB 83F836              <1> .6: cmp ax, 0x36
  1367 00000AAE 7505                <1>     jne .7
  1368 00000AB0 B8[D800]            <1>     mov ax, char_6
  1369 00000AB3 EB5F                <1>     jmp .done
  1370                              <1> 
  1371 00000AB5 83F837              <1> .7: cmp ax, 0x37
  1372 00000AB8 7505                <1>     jne .8
  1373 00000ABA B8[E000]            <1>     mov ax, char_7
  1374 00000ABD EB55                <1>     jmp .done
  1375                              <1> 
  1376 00000ABF 83F838              <1> .8: cmp ax, 0x38
  1377 00000AC2 7505                <1>     jne .9 
  1378 00000AC4 B8[E800]            <1>     mov ax, char_8
  1379 00000AC7 EB4B                <1>     jmp .done
  1380                              <1> 
  1381 00000AC9 83F839              <1> .9: cmp ax, 0x39
  1382 00000ACC 7505                <1>     jne .A
  1383 00000ACE B8[F000]            <1>     mov ax, char_9
  1384 00000AD1 EB41                <1>     jmp .done
  1385                              <1> 
  1386 00000AD3 83F841              <1> .A: cmp ax, 0x41
  1387 00000AD6 7505                <1>     jne .B
  1388 00000AD8 B8[F800]            <1>     mov ax, char_A
  1389 00000ADB EB37                <1>     jmp .done
  1390                              <1> 
  1391 00000ADD 83F842              <1> .B: cmp ax, 0x42
  1392 00000AE0 7505                <1>     jne .C
  1393 00000AE2 B8[0001]            <1>     mov ax, char_B
  1394 00000AE5 EB2D                <1>     jmp .done
  1395                              <1> 
  1396 00000AE7 83F843              <1> .C: cmp ax, 0x43
  1397 00000AEA 7505                <1>     jne .D 
  1398 00000AEC B8[0801]            <1>     mov ax, char_C
  1399 00000AEF EB23                <1>     jmp .done
  1400                              <1> 
  1401 00000AF1 83F844              <1> .D: cmp ax, 0x44
  1402 00000AF4 7505                <1>     jne .E 
  1403 00000AF6 B8[1001]            <1>     mov ax, char_D
  1404 00000AF9 EB19                <1>     jmp .done
  1405                              <1> 
  1406 00000AFB 83F845              <1> .E: cmp ax, 0x45
  1407 00000AFE 7505                <1>     jne .F 
  1408 00000B00 B8[1801]            <1>     mov ax, char_E
  1409 00000B03 EB0F                <1>     jmp .done
  1410                              <1> 
  1411 00000B05 83F846              <1> .F: cmp ax, 0x46
  1412 00000B08 7505                <1>     jne .default ; NOTE THE CUSTOM END OF SWITCHING!
  1413 00000B0A B8[2001]            <1>     mov ax, char_F
  1414 00000B0D EB05                <1>     jmp .done
  1415                              <1> 
  1416                              <1> .default:
  1417 00000B0F B8[2801]            <1>     mov ax, char_default
  1418 00000B12 EB00                <1>     jmp .done
  1419                              <1> 
  1420                              <1> .done:
  1421 00000B14 C3                  <1>     ret
  1422                              <1> char_ascii_to_bitmap_address_end:
  1423                              <1> 
  1424                              <1> ; routine is heavily commented for the sake of learning!
  1425                              <1> write_char_from_bitmap_address:
  1426 00000B15 55                  <1>     push bp
  1427 00000B16 89E5                <1>     mov bp, sp
  1428                              <1> 
  1429                              <1>     ; char bitmap address
  1430 00000B18 8B7608              <1>     mov si, [bp+8]
  1431                              <1> 
  1432                              <1>     ; set up buffer segment
  1433 00000B1B B80070              <1>     mov ax, VIDEO_D_BUFFER
  1434 00000B1E 8EC0                <1>     mov es, ax
  1435                              <1> 
  1436                              <1> 
  1437 00000B20 B90800              <1>     mov cx, 8               ; row loop inex == char height
  1438                              <1> .draw_row:
  1439 00000B23 AC                  <1>     lodsb                   ; load letter byte (si) into ax
  1440 00000B24 51                  <1>     push word cx            ; Save row counter, as cx will be used for column indexing loop
  1441                              <1> 
  1442                              <1>     ; Set leftmost location of new row
  1443 00000B25 8B7E06              <1>     mov di, [bp+6]          ; Start at the Y-coordinate
  1444 00000B28 69FF4001            <1>     imul di, 320            ; Multiply Y by screen width (320)
  1445 00000B2C 037E04              <1>     add di, [bp+4]          ; Add X-coordinate to get pixel offset
  1446                              <1> 
  1447 00000B2F B90800              <1>     mov cx, 8               ; Column loop index == char width
  1448                              <1> .draw_pixel:
  1449 00000B32 A880                <1>     test al, 10000000b      ; Test the most significant bit (1 pixel)
  1450 00000B34 7404                <1>     jz .next_pixel          ; If 0, skip drawing the pixel
  1451                              <1> 
  1452 00000B36 26C6050F            <1>     mov byte [es:di], 0x0F  ; DRAW PIXEL
  1453                              <1> 
  1454                              <1> .next_pixel:                ; always move to next pixel
  1455 00000B3A D0E0                <1>     shl al, 1               ; next letter bit for comparison
  1456 00000B3C 47                  <1>     inc di                  ; Move to the next framebuffer byte
  1457 00000B3D E2F3                <1>     loop .draw_pixel        ; Repeat for all 8 pixels in the row
  1458                              <1> 
  1459 00000B3F FF4606              <1>     inc word [bp+6]         ; Move to the next row by incrementing y
  1460                              <1> 
  1461 00000B42 59                  <1>     pop word cx             ; Restore row counter
  1462 00000B43 E2DE                <1>     loop .draw_row          ; dec cx + cmp cx, 0 + jnz .draw_row ?
  1463                              <1> 
  1464                              <1> 
  1465 00000B45 89EC                <1>     mov sp, bp
  1466 00000B47 5D                  <1>     pop bp
  1467 00000B48 C3                  <1>     ret
  1468                              <1> write_char_from_bitmap_address_end:
  1469                              <1> 
  1470                              <1> 
  1471                              <1> 
  1472                              <1> ; @ x [i16] - bp + 4
  1473                              <1> ; @ y [i16] - bp + 6
  1474                              <1> ; @ c [i16] - bp + 8
  1475                              <1> draw_2x2:
  1476                              <1> 
  1477                              <1>     ; save previous stack frame. Then set up new one. 
  1478 00000B49 55                  <1>     push bp
  1479 00000B4A 89E5                <1>     mov bp, sp ; can't use stack pointer for effective address calculation
  1480                              <1>     
  1481 00000B4C B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1482 00000B4F 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1483                              <1> 
  1484                              <1>     ; Set color
  1485 00000B51 8A5608              <1>     mov dl, BYTE [bp + 8] ; col 1
  1486 00000B54 8A7608              <1>     mov dh, BYTE [bp + 8] ; col 2
  1487                              <1> 
  1488                              <1>     ; set first row y value
  1489 00000B57 BF4001              <1>     mov di, 320
  1490 00000B5A 8B4606              <1>     mov ax, WORD [bp + 6]
  1491 00000B5D 0FAFF8              <1>     imul di, ax ; y
  1492                              <1> 
  1493 00000B60 8B4604              <1>     mov ax, WORD [bp + 4]
  1494 00000B63 01C7                <1>     add di, ax ; x
  1495                              <1> 
  1496 00000B65 268915              <1>     mov [es:di], dx     ; write first pixel row
  1497                              <1> 
  1498                              <1>     ; second row 
  1499 00000B68 81C74001            <1>     add di, 320
  1500 00000B6C 268915              <1>     mov [es:di], dx     ; write second pixel row
  1501                              <1> 
  1502                              <1>     
  1503                              <1>     ; reset stack to call entrypoint
  1504 00000B6F 89EC                <1>     mov sp, bp
  1505 00000B71 5D                  <1>     pop bp
  1506                              <1> 
  1507                              <1>     ; Option # 1
  1508 00000B72 58                  <1>     pop ax ; return adress
  1509 00000B73 FFE0                <1>     jmp ax
  1510                              <1>     ; Option # 2
  1511 00000B75 C3                  <1>     ret
  1512                              <1> 
  1513                              <1> 
  1514                              <1> draw_wasd_input:
  1515                              <1> 
  1516                              <1> .w:
  1517 00000B76 833E[3801]01        <1>     cmp WORD [w_pressed], 1
  1518 00000B7B 7512                <1>     jne .a
  1519                              <1> 
  1520                              <1>     ; .w_draw_press:
  1521                              <1>     ; mov ax, 20
  1522                              <1>     ; mov bx, 162
  1523                              <1>     ; mov si, 0x02
  1524                              <1>     ; call pixel_x_cx_y_dx_c_si
  1525                              <1>     ; jmp .a
  1526                              <1> 
  1527 00000B7D B81400              <1>     mov ax, 20
  1528 00000B80 BBA000              <1>     mov bx, 160
  1529 00000B83 B90500              <1>     mov cx, 5 ; width
  1530 00000B86 BA0500              <1>     mov dx, 5 ; height
  1531 00000B89 BE0200              <1>     mov si, 0x02
  1532 00000B8C E80801              <1>     call draw_square
  1533                              <1> 
  1534                              <1> 
  1535                              <1> 
  1536                              <1>     .a:
  1537 00000B8F 833E[4001]01        <1>     cmp WORD [a_pressed], 1 ; a = left
  1538 00000B94 7512                <1>     jne .s
  1539                              <1> 
  1540                              <1>     ; mov ax, 17
  1541                              <1>     ; mov bx, 165
  1542                              <1>     ; mov si, 0x04
  1543                              <1>     ; call pixel_x_cx_y_dx_c_si
  1544                              <1>     ; jmp .wasd_done
  1545 00000B96 B80F00              <1>     mov ax, 15
  1546 00000B99 BBA500              <1>     mov bx, 165
  1547 00000B9C B90500              <1>     mov cx, 5 ; width
  1548 00000B9F BA0500              <1>     mov dx, 5 ; height
  1549 00000BA2 BE0400              <1>     mov si, 0x04
  1550 00000BA5 E8EF00              <1>     call draw_square
  1551                              <1> 
  1552                              <1> 
  1553                              <1>     .s:
  1554 00000BA8 833E[4201]01        <1>     cmp WORD [s_pressed], 1 ; s = down
  1555 00000BAD 7512                <1>     jne .d
  1556                              <1> 
  1557                              <1>     ; mov ax, 20
  1558                              <1>     ; mov bx, 165
  1559                              <1>     ; mov si, 0x0F
  1560                              <1>     ; call pixel_x_cx_y_dx_c_si
  1561                              <1>     ; jmp .wasd_done
  1562                              <1> 
  1563 00000BAF B81400              <1>     mov ax, 20
  1564 00000BB2 BBA500              <1>     mov bx, 165
  1565 00000BB5 B90500              <1>     mov cx, 5 ; width
  1566 00000BB8 BA0500              <1>     mov dx, 5 ; height
  1567 00000BBB BE0F00              <1>     mov si, 0x0F
  1568 00000BBE E8D600              <1>     call draw_square
  1569                              <1> 
  1570                              <1> 
  1571                              <1> 
  1572                              <1>     .d:
  1573 00000BC1 833E[4401]01        <1>     cmp WORD [d_pressed], 1 ; d = right
  1574 00000BC6 7512                <1>     jne .next
  1575                              <1> 
  1576                              <1>     ; mov ax, 23
  1577                              <1>     ; mov bx, 165
  1578                              <1>     ; mov si, 0x03
  1579                              <1>     ; call pixel_x_cx_y_dx_c_si
  1580                              <1> 
  1581                              <1>     ; SQUARE TEST
  1582 00000BC8 B81900              <1>     mov ax, 25
  1583 00000BCB BBA500              <1>     mov bx, 165
  1584 00000BCE B90500              <1>     mov cx, 5 ; width
  1585 00000BD1 BA0500              <1>     mov dx, 5 ; height
  1586 00000BD4 BE0300              <1>     mov si, 0x03
  1587 00000BD7 E8BD00              <1>     call draw_square
  1588                              <1> 
  1589                              <1>     .next:
  1590                              <1> 
  1591                              <1>     
  1592                              <1> 
  1593                              <1> 
  1594                              <1>     .wasd_done:
  1595                              <1> 
  1596 00000BDA C3                  <1>     ret
  1597                              <1> 
  1598                              <1> ; Clear the screen
  1599                              <1> clear_screen_old:
  1600 00000BDB 60                  <1>     pusha
  1601 00000BDC B406                <1>     mov ah, 0x06    ; Scroll up function
  1602 00000BDE B000                <1>     mov al, 0       ; Clear entire screen
  1603 00000BE0 B708                <1>     mov bh, 0x08    ; dark gray
  1604 00000BE2 B500                <1>     mov ch, 0       ; Upper left row
  1605 00000BE4 B100                <1>     mov cl, 0       ; Upper left column
  1606 00000BE6 B618                <1>     mov dh, 24      ; Lower right row
  1607 00000BE8 B24F                <1>     mov dl, 79      ; Lower right column
  1608 00000BEA CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1609 00000BEC 61                  <1>     popa
  1610 00000BED C3                  <1>     ret
  1611                              <1> 
  1612                              <1> 
  1613                              <1> draw_tests:
  1614                              <1> ; 2024-10-31 : six lines added to add two new pixels!
  1615 00000BEE B90200              <1>     mov cx, 2     ; X position for second pixel
  1616 00000BF1 BA0200              <1>     mov dx, 2     ; Y position for second pixel
  1617 00000BF4 CD10                <1>     int 0x10
  1618 00000BF6 B90300              <1>     mov cx, 3     ; X position for second pixel
  1619 00000BF9 BA0300              <1>     mov dx, 3     ; Y position for second pixel
  1620 00000BFC CD10                <1>     int 0x10
  1621                              <1> 
  1622                              <1> 
  1623 00000BFE B90300              <1>     mov cx, 3     ; X position for second pixel
  1624 00000C01 BA0300              <1>     mov dx, 3     ; Y position for second pixel
  1625 00000C04 CD10                <1>     int 0x10
  1626                              <1> 
  1627                              <1>     ; 2024-10-31 : testing array
  1628 00000C06 8B0E[5202]          <1>     mov cx, [word_array]     ; array pos. 5
  1629 00000C0A 8B16[5202]          <1>     mov dx, [word_array]     ; array pos. 5
  1630                              <1>     ; mov cx, 10     ; array pos. 5
  1631                              <1>     ; mov dx, 10     ; array pos. 5
  1632 00000C0E CD10                <1>     int 0x10
  1633                              <1> 
  1634                              <1> 
  1635                              <1> 
  1636                              <1> ; Draw large square -- INTERRUPT BASED
  1637                              <1> draw_large_square:
  1638 00000C10 B406                <1>     mov ah, 0x06    ; Scroll up 
  1639 00000C12 B706                <1>     mov bh, 0x06    ; color
  1640 00000C14 B50A                <1>     mov ch, 10      ; Upper left x of square
  1641 00000C16 B10A                <1>     mov cl, 10      ; Upper left y of square
  1642 00000C18 B614                <1>     mov dh, 20      ; Lower right x of square
  1643 00000C1A B214                <1>     mov dl, 20      ; Lower right y of square
  1644 00000C1C CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1645 00000C1E C3                  <1>     ret
  1646                              <1> 
  1647                              <1> 
  1648                              <1> ; Draw a pixel at (x, y) with color
  1649                              <1> ; mode h13 is set at the beginning of the program
  1650                              <1> mode_13h_pixel_draw:
  1651 00000C1F B800A0              <1>     mov ax,0a000h
  1652 00000C22 8EC0                <1>     mov es,ax
  1653 00000C24 B81400              <1>     mov ax,20    ; y = 20
  1654 00000C27 BB1400              <1>     mov bx,20
  1655 00000C2A C1E008              <1>     shl ax,8
  1656 00000C2D C1E306              <1>     shl bx,6
  1657 00000C30 01D8                <1>     add ax,bx
  1658 00000C32 83C01E              <1>     add ax,30    ; x = 30
  1659 00000C35 89C7                <1>     mov di,ax
  1660 00000C37 B002                <1>     mov al,2    ; color = 2 = green
  1661 00000C39 268805              <1>     mov es:[di],al
  1662 00000C3C C3                  <1>     ret
  1663                              <1> 
  1664                              <1> ; Draw the 'current' pixel 
  1665                              <1> draw_input_incrementing_pixel:
  1666                              <1> 
  1667 00000C3D A1[5C02]            <1>     mov ax, [pixel_x]
  1668 00000C40 8B1E[5E02]          <1>     mov bx, [pixel_y]
  1669 00000C44 BE0F00              <1>     mov si, 0x0F
  1670 00000C47 E89500              <1>     call pixel_x_cx_y_dx_c_si
  1671                              <1> 
  1672 00000C4A C3                  <1>     ret
  1673                              <1> 
  1674                              <1> 
  1675                              <1> ;  try to understand the key_code values
  1676                              <1> ; Draw al as x, and ah as y
  1677                              <1> draw_keycode_coords:
  1678 00000C4B B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
  1679 00000C4D B00A                <1>     mov al, 0x0A  ; White color
  1680 00000C4F 31C9                <1>     xor cx, cx
  1681 00000C51 31D2                <1>     xor dx, dx
  1682 00000C53 8B0E[3401]          <1>     mov cx, [key_code_al]
  1683 00000C57 8B16[3201]          <1>     mov dx, [key_code_ah]
  1684 00000C5B CD10                <1>     int 0x10
  1685 00000C5D C3                  <1>     ret
  1686                              <1> 
  1687                              <1> ; draw pixel test
  1688                              <1> simple_pixel:
  1689 00000C5E B86400              <1>     mov ax, 100
  1690 00000C61 BB4600              <1>     mov bx, 70
  1691 00000C64 BE0F00              <1>     mov si, 0x0f
  1692 00000C67 E87500              <1>     call pixel_x_cx_y_dx_c_si
  1693 00000C6A C3                  <1>     ret
  1694                              <1> 
  1695                              <1> clear:
  1696                              <1>     ; clear screen using graphics mode writing directly to video buffer
  1697 00000C6B B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for graphics video memory
  1698 00000C6E 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1699 00000C70 BF0000              <1>     mov di, 0              ; Start at the top-left corner
  1700 00000C73 B9007D              <1>     mov cx, 320 * 200 / 2  ; rep stosw increments two bytes per iteration
  1701 00000C76 B8CFCF              <1>     mov ax, 0xCFCF ; 2 x mode 13h color palette (1 byte / pixel)
  1702                              <1>     
  1703                              <1>     ; Increments di by 2 each iteration (default DF=0) and loads ax into [es:di] and stops at di=cx?
  1704                              <1>     ; stosw : w=word=eax, stosb : w=byte,
  1705 00000C79 F3AB                <1>     rep stosw
  1706                              <1> 
  1707 00000C7B C3                  <1>     ret
  1708                              <1> 
  1709                              <1> 
  1710                              <1> 
  1711                              <1> write_oooo:
  1712                              <1>     ; Set cursor position   
  1713                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
  1714                              <1>     ; mov al, 0
  1715                              <1>     ; mov ah, 0x02
  1716                              <1>     ; mov bh, 1
  1717                              <1>     ; mov dh, 10
  1718                              <1>     ; mov dl, 0
  1719                              <1>     ; int 0x10
  1720                              <1> 
  1721 00000C7C B409                <1>     mov ah, 0x09
  1722 00000C7E B04F                <1>     mov al, 'O'   ;' write char directly
  1723 00000C80 B701                <1>     mov bh, 1    ; page?
  1724 00000C82 B306                <1>     mov bl, 0x06    ; color
  1725 00000C84 B90A00              <1>     mov cx, 10      ; # times to write
  1726 00000C87 B90100              <1>     mov cx, 1      ; # times to write
  1727 00000C8A CD10                <1>     int 0x10        ; Call BIOS video interrupt
  1728 00000C8C C3                  <1>     ret
  1729                              <1> 
  1730                              <1> 
  1731                              <1> 
  1732                              <1> 
  1733                              <1> 
  1734                              <1> ; draw square 'local' variables
  1735                              <1> ; I don't have a stack yet...
  1736 00000C8D 0000                <1> sq_hh dw 0
  1737 00000C8F 0000                <1> sq_ww dw 0
  1738 00000C91 0000                <1> sq_xx dw 0
  1739 00000C93 0000                <1> sq_yy dw 0
  1740 00000C95 0000                <1> sq_cc dw 0
  1741                              <1> ; Draw a square at (ax, bx), with (h, w)=(cx, dx), and color=si
  1742                              <1> draw_square:
  1743                              <1>     ; 'push' arguments
  1744 00000C97 A3[910C]            <1>     mov [sq_xx], ax
  1745 00000C9A 891E[930C]          <1>     mov [sq_yy], bx
  1746 00000C9E 890E[8F0C]          <1>     mov [sq_ww], cx
  1747 00000CA2 8916[8D0C]          <1>     mov [sq_hh], dx
  1748 00000CA6 8936[950C]          <1>     mov [sq_cc], si
  1749                              <1> 
  1750                              <1> ; video segment
  1751 00000CAA B80070              <1>     mov ax, VIDEO_D_BUFFER
  1752 00000CAD 8EC0                <1>     mov es, ax
  1753                              <1> 
  1754                              <1> 
  1755                              <1> ; row-index
  1756 00000CAF B90000              <1>     mov cx, 0
  1757                              <1> .L_ROW:
  1758                              <1>     ; Set di to point to leftmost in current row
  1759 00000CB2 8B3E[930C]          <1>     mov di, [sq_yy]
  1760 00000CB6 01CF                <1>     add di, cx
  1761 00000CB8 69FF4001            <1>     imul di, 320 ; y
  1762 00000CBC 033E[910C]          <1>     add di, [sq_xx] ; x
  1763                              <1>     
  1764                              <1> 
  1765                              <1> ; column-index
  1766 00000CC0 BA0000              <1>     mov dx, 0
  1767                              <1> .L_COLUMN:
  1768                              <1> 
  1769                              <1>     ; DRAW PIXEL
  1770 00000CC3 A0[950C]            <1>     mov al, [sq_cc] ; color
  1771 00000CC6 268805              <1>     mov [es:di], al ; location
  1772                              <1> 
  1773                              <1>     ; next pixel location -- x-direction
  1774                              <1>     ; increment AFTER draw to properly draw with zero index
  1775 00000CC9 47                  <1>     inc di
  1776                              <1> 
  1777                              <1>     ; increment col-index until height is reached
  1778 00000CCA 42                  <1>     inc dx
  1779 00000CCB 3B16[8F0C]          <1>     cmp dx, WORD [sq_ww]
  1780 00000CCF 7CF2                <1>     jl .L_COLUMN
  1781                              <1> 
  1782                              <1> .L_COLUMN_END:  
  1783                              <1> 
  1784                              <1>     ; keep incrementing row-index until height is reached
  1785 00000CD1 41                  <1>     inc cx
  1786 00000CD2 3B0E[8D0C]          <1>     cmp cx, WORD [sq_hh]
  1787 00000CD6 7CDA                <1>     jl .L_ROW 
  1788                              <1> 
  1789 00000CD8 C3                  <1>     ret
  1790                              <1> 
  1791                              <1> 
  1792                              <1> 
  1793                              <1> 
  1794                              <1> 
  1795                              <1> ; draw pixel variables
  1796 00000CD9 0000                <1> xx dw 0
  1797 00000CDB 0000                <1> yy dw 0
  1798 00000CDD 0000                <1> cc dw 0
  1799                              <1> ; Draw a pixel at (cx, dx), with color (si)
  1800                              <1> pixel_x_cx_y_dx_c_si:
  1801 00000CDF A3[D90C]            <1>     mov [xx], ax
  1802 00000CE2 891E[DB0C]          <1>     mov [yy], bx
  1803 00000CE6 8936[DD0C]          <1>     mov [cc], si
  1804                              <1> 
  1805 00000CEA B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1806 00000CED 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1807                              <1> 
  1808                              <1> 
  1809 00000CEF BF4001              <1>     mov di, 320
  1810 00000CF2 0FAF3E[DB0C]        <1>     imul di, [yy] ; y
  1811 00000CF7 033E[D90C]          <1>     add di, [xx] ; x
  1812 00000CFB A0[DD0C]            <1>     mov al, [cc]           ; Pixel color (bright white)
  1813                              <1> 
  1814 00000CFE 268805              <1>     mov [es:di], al        ; Write pixel color to video memory
  1815 00000D01 C3                  <1>     ret
  1816                              <1>  
  1817                              <1> 
  1818                              <1> ; single blue and white pixels
  1819                              <1> extern_pixels:
  1820 00000D02 B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
  1821 00000D04 B001                <1>     mov al, 0x01  ; color -- Blue 
  1822 00000D06 B93200              <1>     mov cx, 50
  1823 00000D09 BA3200              <1>     mov dx, 50
  1824 00000D0C CD10                <1>     int 0x10
  1825                              <1> 
  1826                              <1>     ; mov ax, 0xA000
  1827                              <1>     ; add ax, (320 * 50 + 50)
  1828                              <1>     ; mov [ax]
  1829                              <1>     
  1830 00000D0E B80070              <1>     mov ax, VIDEO_D_BUFFER         ; Segment for video memory
  1831 00000D11 8EC0                <1>     mov es, ax             ; Point ES to video memory
  1832                              <1> 
  1833 00000D13 BFF33F              <1>     mov di, (320 * 51 + 51) ; Offset for pixel at (100, 50)
  1834 00000D16 B007                <1>     mov al, 0x07           ; Pixel color (bright white)
  1835                              <1> 
  1836 00000D18 268805              <1>     mov [es:di], al        ; Write pixel color to video memory
  1837                              <1> 
  1838 00000D1B C3                  <1>     ret
   366                                  %include "./draw/keyboard.asm"
     1                              <1> ; section .data
     2                              <1> 
     3                              <1> ; ; KEYBOARD INPUT CODE
     4                              <1> ; key_code dw 0
     5                              <1> ; key_code_ah dw 0
     6                              <1> ; key_code_al dw 0
     7                              <1> ; ; mov WORD [key_code_ah], 0
     8                              <1> 
     9                              <1> 
    10                              <1> 
    11                              <1> ; ; key-flags indicating that the key is currently pressed
    12                              <1> ; press_event dw 0 ; 1 = pressed, 0 = released
    13                              <1> ; w_pressed dw 0
    14                              <1> ; mov WORD [w_pressed], 0x0000
    15                              <1> ; a_pressed dw 0
    16                              <1> ; s_pressed dw 0
    17                              <1> ; d_pressed dw 0
    18                              <1> 
    19                              <1> ; ascii_current_press dw 0
    20                              <1> ; cursor_buffer times 256 db 0
    21                              <1> ; cursor_count dw 0
    22                              <1> ; cursor_c dw 0
    23                              <1> ; cursor_r dw 19
    24                              <1> ; cursor_w dw 10
    25                              <1> ; cursor_h dw 10
    26                              <1> 
    27                              <1> 
    28                              <1> ; section .text
    29                              <1> 
    30                              <1> 
    31                              <1> ; Keyboard interrupt handler
    32                              <1> ; Will break the main loop and update the rendered content
    33                              <1> keyboard_handler:
    34                              <1> 
    35 00000D1C 60                  <1>     pusha ; Need .286 direcctive? - 2024-10-31 - https://stackoverflow.com/questions/29728171/x86-assembly-set-of-pushes-and-pusha-difference
    36 00000D1D E460                <1>     in al, 0x60  ; Read keyboard scancode
    37                              <1> 
    38                              <1>     ; store key-information on initial interrupt
    39 00000D1F A3[3001]            <1>     mov [key_code], ax
    40 00000D22 8826[3201]          <1>     mov [key_code_ah], ah
    41 00000D26 A2[3401]            <1>     mov [key_code_al], al
    42                              <1> 
    43                              <1> 
    44                              <1>     ; DETECT KEY PRESS OR RELEASE
    45 00000D29 A880                <1>     test al, 0x80      ; highest bit is press/release flag
    46 00000D2B 7511                <1>     jnz .key_released  ; Bit was set = release
    47                              <1> 
    48                              <1>     .key_pressed:
    49 00000D2D C706[3601]0100      <1>     mov WORD [press_event], 0x1
    50                              <1>     ; call .write_press_key_code_char
    51 00000D33 E80E01              <1>     call wasd_update
    52                              <1> 
    53                              <1>     ; Register ascii press
    54 00000D36 A1[3401]            <1>     mov ax, word [key_code_al]
    55 00000D39 E81B00              <1>     call store_ascii_pressed
    56                              <1>     
    57 00000D3C EB13                <1>     jmp .key_flag_done
    58                              <1> 
    59                              <1>     .key_released:
    60 00000D3E C706[3601]0000      <1>     mov WORD [press_event], 0x0
    61 00000D44 802E[3001]80        <1>     sub BYTE [key_code], 0x80 ; get the key release value by subtracting release-flag
    62 00000D49 802E[3401]80        <1>     sub BYTE [key_code_al], 0x80 ; get the key release value by subtracting release-flag
    63 00000D4E E8F300              <1>     call wasd_update
    64                              <1>     ; call .write_release_key_code_char
    65                              <1>     
    66                              <1>     .key_flag_done:
    67                              <1>     
    68                              <1>     ; call float_tests
    69                              <1> 
    70                              <1> 
    71 00000D51 B020                <1>     mov al, 0x20
    72 00000D53 E620                <1>     out 0x20, al  ; Send EOI to PIC
    73 00000D55 61                  <1>     popa
    74 00000D56 CF                  <1>     iret ; interrupt - meaning : 2024-10-31
    75                              <1> _keyboard_handler:
    76                              <1> 
    77                              <1> 
    78                              <1> 
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ; input: ax = raw keyboard press 'al' value 
    83                              <1> store_ascii_pressed:
    84                              <1>     ; mov ax, word [key_code_al]
    85                              <1> 
    86                              <1> 
    87 00000D57 83F80B              <1> ._0: cmp ax, 0x0B
    88 00000D5A 7509                <1>     jne ._1 
    89 00000D5C C706[4602]3000      <1>     mov word [ascii_current_press], '0'
    90 00000D62 E9D000              <1>     jmp .match
    91                              <1> 
    92 00000D65 83F802              <1> ._1: cmp ax, 0x02
    93 00000D68 7509                <1>     jne ._2
    94 00000D6A C706[4602]3100      <1>     mov word [ascii_current_press], '1'
    95 00000D70 E9C200              <1>     jmp .match
    96                              <1> 
    97 00000D73 83F803              <1> ._2: cmp ax, 0x03
    98 00000D76 7509                <1>     jne ._3
    99 00000D78 C706[4602]3200      <1>     mov word [ascii_current_press], '2'
   100 00000D7E E9B400              <1>     jmp .match
   101                              <1> 
   102 00000D81 83F804              <1> ._3: cmp ax, 0x04
   103 00000D84 7509                <1>     jne ._4
   104 00000D86 C706[4602]3300      <1>     mov word [ascii_current_press], '3'
   105 00000D8C E9A600              <1>     jmp .match
   106                              <1> 
   107 00000D8F 83F805              <1> ._4: cmp ax, 0x05
   108 00000D92 7509                <1>     jne ._5
   109 00000D94 C706[4602]3400      <1>     mov word [ascii_current_press], '4'
   110 00000D9A E99800              <1>     jmp .match
   111                              <1> 
   112 00000D9D 83F806              <1> ._5: cmp ax, 0x06
   113 00000DA0 7509                <1>     jne ._6
   114 00000DA2 C706[4602]3500      <1>     mov word [ascii_current_press], '5'
   115 00000DA8 E98A00              <1>     jmp .match
   116                              <1> 
   117 00000DAB 83F807              <1> ._6: cmp ax, 0x07
   118 00000DAE 7508                <1>     jne ._7 
   119 00000DB0 C706[4602]3600      <1>     mov word [ascii_current_press], '6'
   120 00000DB6 EB7D                <1>     jmp .match
   121                              <1> 
   122 00000DB8 83F808              <1> ._7: cmp ax, 0x08
   123 00000DBB 7508                <1>     jne ._8
   124 00000DBD C706[4602]3700      <1>     mov word [ascii_current_press], '7'
   125 00000DC3 EB70                <1>     jmp .match
   126                              <1> 
   127 00000DC5 83F809              <1> ._8: cmp ax, 0x09
   128 00000DC8 7508                <1>     jne ._9
   129 00000DCA C706[4602]3800      <1>     mov word [ascii_current_press], '8'
   130 00000DD0 EB63                <1>     jmp .match
   131                              <1> 
   132 00000DD2 83F80A              <1> ._9: cmp ax, 0x0A
   133 00000DD5 7508                <1>     jne .a
   134 00000DD7 C706[4602]3900      <1>     mov word [ascii_current_press], '9'
   135 00000DDD EB56                <1>     jmp .match
   136                              <1> 
   137 00000DDF 83F81E              <1> .a: cmp ax, 30
   138 00000DE2 7508                <1>     jne .b
   139 00000DE4 C706[4602]4100      <1>     mov word [ascii_current_press], 'A'
   140 00000DEA EB49                <1>     jmp .match
   141                              <1> 
   142 00000DEC 83F830              <1> .b: cmp ax, 0x30
   143 00000DEF 7508                <1>     jne .c
   144 00000DF1 C706[4602]4200      <1>     mov word [ascii_current_press], 'B'
   145 00000DF7 EB3C                <1>     jmp .match
   146                              <1> 
   147 00000DF9 83F82E              <1> .c: cmp ax, 0x2E
   148 00000DFC 7508                <1>     jne .d
   149 00000DFE C706[4602]4300      <1>     mov word [ascii_current_press], 'C'
   150 00000E04 EB2F                <1>     jmp .match
   151                              <1> 
   152 00000E06 83F820              <1> .d: cmp ax, 32
   153 00000E09 7508                <1>     jne .e
   154 00000E0B C706[4602]4400      <1>     mov word [ascii_current_press], 'D'
   155 00000E11 EB22                <1>     jmp .match
   156                              <1> 
   157 00000E13 83F812              <1> .e: cmp ax, 18
   158 00000E16 7508                <1>     jne .f
   159 00000E18 C706[4602]4500      <1>     mov word [ascii_current_press], 'E'
   160 00000E1E EB15                <1>     jmp .match
   161                              <1> 
   162 00000E20 83F821              <1> .f: cmp ax, 33
   163 00000E23 7508                <1>     jne .no_match ; NOTE THE CUSTOM END OF SWITCHING!
   164 00000E25 C706[4602]4600      <1>     mov word [ascii_current_press], 'F'
   165 00000E2B EB08                <1>     jmp .match
   166                              <1> 
   167                              <1> .no_match:
   168 00000E2D C706[4602]0000      <1>     mov word [ascii_current_press], 0x00
   169 00000E33 EB0E                <1>     jmp .done
   170                              <1> 
   171                              <1> 
   172                              <1> .match:
   173                              <1>     ; write current press to cursor buffer
   174 00000E35 A1[4602]            <1>     mov ax, word [ascii_current_press]
   175 00000E38 8B0E[4802]          <1>     mov cx, word [cursor_count] ; current count
   176 00000E3C BB[4601]            <1>     mov bx, cursor_buffer
   177 00000E3F 01CB                <1>     add bx, cx
   178 00000E41 8807                <1>     mov byte [bx], al
   179                              <1>     ; inc word [cursor_count]
   180                              <1> .done:
   181 00000E43 C3                  <1>     ret
   182                              <1> 
   183                              <1> 
   184                              <1> ; Toggle key states
   185                              <1> wasd_update:
   186                              <1> 
   187                              <1> 
   188                              <1> ; SWITCH STATEMENT
   189                              <1> 
   190                              <1> .w:
   191 00000E44 833E[3401]11        <1>     cmp WORD [key_code_al], 17 ; w = up
   192 00000E49 7517                <1>     jne .a
   193                              <1> 
   194 00000E4B 833E[3601]01        <1>     cmp WORD [press_event], 1 ; is pressing
   195 00000E50 7408                <1>     je .w_press
   196                              <1> 
   197                              <1> .w_release:
   198 00000E52 C706[3801]0000      <1>     mov WORD [w_pressed], 0x0000
   199 00000E58 EB62                <1>     jmp .wasd_done
   200                              <1>     
   201                              <1> .w_press:
   202 00000E5A C706[3801]0100      <1>     mov WORD [w_pressed], 1
   203 00000E60 EB5A                <1>     jmp .wasd_done
   204                              <1> 
   205                              <1> 
   206                              <1> 
   207                              <1> .a:
   208 00000E62 833E[3401]1E        <1>     cmp WORD [key_code_al], 30 ; a = left
   209 00000E67 7517                <1>     jne .s
   210                              <1> 
   211                              <1> 
   212 00000E69 833E[3601]01        <1>     cmp WORD [press_event], 1 ; is pressing
   213 00000E6E 7408                <1>     je .a_press
   214                              <1> 
   215                              <1>     .a_release:
   216 00000E70 C706[4001]0000      <1>     mov WORD [a_pressed], 0x0000
   217 00000E76 EB44                <1>     jmp .wasd_done
   218                              <1>     
   219                              <1>     .a_press:
   220 00000E78 C706[4001]0100      <1>     mov WORD [a_pressed], 1
   221 00000E7E EB3C                <1>     jmp .wasd_done
   222                              <1> 
   223                              <1> 
   224                              <1> 
   225                              <1> 
   226                              <1> .s:
   227 00000E80 833E[3401]1F        <1>     cmp WORD [key_code_al], 31 ; s = down
   228 00000E85 7517                <1>     jne .d
   229                              <1> 
   230 00000E87 833E[3601]01        <1>     cmp WORD [press_event], 1 ; is pressing
   231 00000E8C 7408                <1>     je .s_press
   232                              <1> 
   233                              <1>     .s_release:
   234 00000E8E C706[4201]0000      <1>     mov WORD [s_pressed], 0x0000
   235 00000E94 EB26                <1>     jmp .wasd_done
   236                              <1>     
   237                              <1>     .s_press:
   238 00000E96 C706[4201]0100      <1>     mov WORD [s_pressed], 1
   239 00000E9C EB1E                <1>     jmp .wasd_done
   240                              <1> 
   241                              <1> 
   242                              <1> 
   243                              <1> .d:
   244 00000E9E 833E[3401]20        <1>     cmp WORD [key_code_al], 32 ; d = right
   245 00000EA3 7517                <1>     jne .next
   246                              <1> 
   247                              <1> 
   248 00000EA5 833E[3601]01        <1>     cmp WORD [press_event], 1 ; is pressing
   249 00000EAA 7408                <1>     je .d_press
   250                              <1> 
   251                              <1>     .d_release:
   252 00000EAC C706[4401]0000      <1>     mov WORD [d_pressed], 0x0000
   253 00000EB2 EB08                <1>     jmp .wasd_done
   254                              <1>     
   255                              <1>     .d_press:
   256 00000EB4 C706[4401]0100      <1>     mov WORD [d_pressed], 1
   257 00000EBA EB00                <1>     jmp .wasd_done
   258                              <1> 
   259                              <1>     .next:
   260                              <1> 
   261                              <1> .wasd_done:
   262                              <1> 
   263 00000EBC C3                  <1>     ret
   264                              <1> 
   265                              <1> 
   266                              <1> 
   267                              <1> ; Navingating using numpad
   268                              <1> ; checking key_code values against tested numpad input value, and change x/y accodingly
   269                              <1> numpad_navigate:
   270                              <1>     ; xor bx, bx
   271                              <1>     ; xor cx, cx
   272                              <1>     ; xor dx, dx
   273                              <1>     ; make additional draw call based on keyboard input
   274                              <1>     ; mov cx, 10 ; = pixel x location
   275                              <1> 
   276                              <1>     ; mov dx, 201
   277 00000EBD 833E[3001]48        <1>     cmp WORD [key_code], 72 ; numpad 8 = up
   278 00000EC2 7417                <1>     je .up
   279 00000EC4 833E[3001]4B        <1>     cmp WORD [key_code], 75 ; numpad 4 = left
   280 00000EC9 741A                <1>     je .left
   281 00000ECB 833E[3001]4C        <1>     cmp WORD [key_code], 76 ; numpad 5 = down
   282 00000ED0 741D                <1>     je .down
   283 00000ED2 833E[3001]4D        <1>     cmp WORD [key_code], 77 ; numpad 6 = right
   284 00000ED7 7420                <1>     je .right
   285                              <1> 
   286 00000ED9 EB28                <1>     jmp .not_equal ; no registered key
   287                              <1> 
   288                              <1>     .up:
   289 00000EDB B002                <1>         mov al, 0x02  ;  green
   290 00000EDD 66832E[6202]02      <1>         sub DWORD [y], 2
   291 00000EE3 EB20                <1>         jmp .dn
   292                              <1>     .left:
   293 00000EE5 B00D                <1>         mov al, 0x0D  ;  pink
   294 00000EE7 66832E[6002]02      <1>         sub DWORD [x], 2
   295 00000EED EB16                <1>         jmp .dn
   296                              <1>     .down:
   297 00000EEF B001                <1>         mov al, 0x01  ;  blue
   298 00000EF1 668306[6202]02      <1>         add DWORD [y], 2
   299 00000EF7 EB0C                <1>         jmp .dn
   300                              <1>     .right:
   301 00000EF9 B00E                <1>         mov al, 0x0E  ;  yellow
   302 00000EFB 668306[6002]02      <1>         add DWORD [x], 2
   303 00000F01 EB02                <1>         jmp .dn
   304                              <1> 
   305                              <1>     .not_equal:
   306 00000F03 B004                <1>     mov al, 0x04  ;  color
   307                              <1> 
   308                              <1>     .dn:
   309                              <1>     ; mov ah, 0x0C  ; BIOS video function: write pixel
   310                              <1>     ; mov al, 0x0F  ; White color
   311                              <1>     ; int 0x10
   312                              <1> 
   313                              <1>     ; Trying to guess values
   314                              <1>     ; mov cx, [key_code]
   315 00000F05 B40C                <1>     mov ah, 0x0C  ; BIOS video function: write pixel
   316                              <1>     ; mov al, 0x0A  ; White color
   317                              <1>     ; xor cx, cx
   318                              <1>     ; xor dx, dx
   319 00000F07 8B0E[6002]          <1>     mov WORD cx, [x]
   320 00000F0B 8B16[6202]          <1>     mov WORD dx, [y]
   321                              <1>     ; mov dx, y
   322 00000F0F CD10                <1>     int 0x10
   323 00000F11 C3                  <1>     ret
   324                              <1> 
   325                              <1> 
   326                              <1> ; Write some chars using AH=09h 
   327                              <1> .write_release_key_code_char:
   328                              <1>     ; Set cursor position
   329                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
   330 00000F12 B402                <1>     mov ah, 0x02
   331 00000F14 B701                <1>     mov bh, 1
   332 00000F16 B606                <1>     mov dh, 6
   333 00000F18 B200                <1>     mov dl, 0
   334 00000F1A CD10                <1>     int 0x10
   335                              <1> 
   336 00000F1C B409                <1>     mov ah, 0x09
   337 00000F1E A0[3001]            <1>     mov al, [key_code]
   338 00000F21 B701                <1>     mov bh, 1    ; page?
   339 00000F23 B306                <1>     mov bl, 0x06    ; color
   340 00000F25 B90200              <1>     mov cx, 2      ; # times to write
   341 00000F28 CD10                <1>     int 0x10        ; Call BIOS video interrupt
   342 00000F2A C3                  <1>     ret
   343                              <1> 
   344                              <1> 
   345                              <1> ; Write some chars using AH=09h 
   346                              <1> .write_press_key_code_char:
   347                              <1>     ; AH=02h 	BH = Page Number, DH = Row, DL = Column
   348 00000F2B B402                <1>     mov ah, 0x02
   349 00000F2D B701                <1>     mov bh, 1
   350 00000F2F B60A                <1>     mov dh, 10
   351 00000F31 B200                <1>     mov dl, 0
   352 00000F33 CD10                <1>     int 0x10
   353                              <1> 
   354 00000F35 B409                <1>     mov ah, 0x09
   355                              <1>     ; mov al, 'A'   ' write char directly
   356 00000F37 A0[3001]            <1>     mov al, [key_code]
   357 00000F3A B701                <1>     mov bh, 1    ; page?
   358 00000F3C B306                <1>     mov bl, 0x06    ; color
   359                              <1>     ; mov cx, 10      ; # times to write
   360 00000F3E B90100              <1>     mov cx, 1      ; # times to write
   361 00000F41 CD10                <1>     int 0x10        ; Call BIOS video interrupt
   362 00000F43 C3                  <1>     ret
   363                              <1> 
   364                              <1> 
   365                              <1> 
   367                                  ; %include "./draw/update_cre_data.asm"
   368                                  ; %include "./draw/text.asm"
   369                                  
   370                                  
   371                                  
   372                                  section .text
   373                                  code_segment_end:
   374                                  
   375 00000F44 00<rep 2BCh>            times 4096-(code_segment_end - code_segment) db 0
   376                                  
   377                                  
   378                                  
   379                                  
   380                                  
   381                                  
   382                                  
   383                                  
   384                                  
   385                                  section .data
   386                                  
   387                                  align 4
   388                                  
   389                                  ; my_data equ 0x0900
   390                                  my_data:
   391                                  
   392                                  
   393                                  
   394                                  
   395                                  
   396                                  %include "./draw/render_data.asm"
     1                              <1> ; NOTE:
     2                              <1> ;   The data below is placed in this separate file for performance reasons.
     3                              <1> ;   When previously placed interleaved between .text section this cpu usage went up significantly. 
     4                              <1> 
     5                              <1> 
     6                              <1> section .data
     7                              <1> ; Double buffering segment
     8                              <1> VIDEO_D_BUFFER equ 0x7000
     9                              <1> 
    10                              <1> 
    11 00000000 14003C000000960050- <1> tri_2d_int_array dw 20, 60, 0, 150, 80, 0, 120, 30, 0
    11 00000009 00000078001E000000  <1>
    12 00000012 0000                <1> slope_int dw 0
    13 00000014 00000000            <1> slope_float dd 0
    14                              <1> 
    15                              <1> ; test_var dw 1000
    16                              <1> 
    17                              <1> ; Testing floating point numbers
    18 00000018 E17AA440            <1> float_1 dd 5.14
    19 0000001C 52B8B640            <1> float_2 dd 5.71
    20 00000020 8FC2A141            <1> float_3 dd 20.22
    21 00000024 00000000            <1> float_res dd 0.0
    22 00000028 0000                <1> integer_res dw 0
    23                              <1> 
    24                              <1> 
    25                              <1> ; Will hold the triangle points to be drawn next
    26                              <1> ; Expressed in screen coordinates
    27                              <1> ; 12 bytes
    28 0000002A 8C008C00BE008C008C- <1> current_triangle_pixels dw  140, 140, 190 ,140 ,140 ,190    ; x0, y0, x1, y1, x2, y2
    28 00000033 00BE00              <1>
    29                              <1> ; 24 bytes          ; x0, y0 &  x1, y1 & x2, y2
    30 00000036 000070420000704200- <1> current_triangle    dd      60.0,   60.0,                              110.0,  60.0,                              60.0,   110.0,
    30 0000003F 00DC42000070420000- <1>
    30 00000048 70420000DC42        <1>
    33                              <1> 
    34                              <1> ; Current, transformed, window coord, float triangle
    35                              <1> ; Used for triangle drawing
    36 0000004E 00000000            <1> p0_x dd 0.0
    37 00000052 00000000            <1> p0_y dd 0.0
    38 00000056 00000000            <1> p1_x dd 0.0
    39 0000005A 00000000            <1> p1_y dd 0.0
    40 0000005E 00000000            <1> p2_x dd 0.0
    41 00000062 00000000            <1> p2_y dd 0.0
    42 00000066 0000                <1> p0_x_int dw 0.0
    43 00000068 0000                <1> p0_y_int dw 0.0
    44 0000006A 0000                <1> p1_x_int dw 0.0
    45 0000006C 0000                <1> p1_y_int dw 0.0
    46 0000006E 0000                <1> p2_x_int dw 0.0
    47 00000070 0000                <1> p2_y_int dw 0.0
    48                              <1> 
    49                              <1> 
    50                              <1> 
    51                              <1> 
    52                              <1> ; Signed area values
    53                              <1> ;
    54                              <1> ; current pixel location for discrete pixel loop
    55 00000072 0000                <1> p_x_int dw 0
    56 00000074 0000                <1> p_y_int dw 0
    57                              <1> ; current triangle loop range
    58 00000076 0000                <1> p_x_int_min dw 0
    59 00000078 0000                <1> p_x_int_max dw 0
    60 0000007A 0000                <1> p_y_int_min dw 0
    61 0000007C 0000                <1> p_y_int_max dw 0
    62                              <1> ; current pixel as float for signed area calcs
    63 0000007E 00000000            <1> p_x dd 0
    64 00000082 00000000            <1> p_y dd 0
    65                              <1> ; Store the signed area calculation to determine if pixel is within triangle, thus if it is to be drawn
    66 00000086 00000000            <1> area_sign_0 dd 0
    67 0000008A 00000000            <1> area_sign_1 dd 0
    68 0000008E 00000000            <1> area_sign_2 dd 0
    69 00000092 0000                <1> area_sign_int_0 dw 0
    70 00000094 0000                <1> area_sign_int_1 dw 0
    71 00000096 0000                <1> area_sign_int_2 dw 0
    72                              <1> 
   397                                  %include "./draw/text.asm"
     1                              <1> 
     2                              <1> 
     3                              <1> section .data
     4                              <1> 
     5                              <1> 
     6 00000098 303132333435363738- <1> hex_print_table: db "0123456789ABCDEF"
     6 000000A1 39414243444546      <1>
     7                              <1> 
     8                              <1> 
     9 000000A8 7E                  <1> char_0    db 01111110b
    10 000000A9 81                  <1>           db 10000001b
    11 000000AA 81                  <1>           db 10000001b
    12 000000AB 81                  <1>           db 10000001b
    13 000000AC 81                  <1>           db 10000001b
    14 000000AD 81                  <1>           db 10000001b
    15 000000AE 81                  <1>           db 10000001b
    16 000000AF 7E                  <1>           db 01111110b
    17                              <1> 
    18 000000B0 18                  <1> char_1    db 00011000b
    19 000000B1 08                  <1>           db 00001000b
    20 000000B2 08                  <1>           db 00001000b
    21 000000B3 08                  <1>           db 00001000b
    22 000000B4 08                  <1>           db 00001000b
    23 000000B5 08                  <1>           db 00001000b
    24 000000B6 08                  <1>           db 00001000b
    25 000000B7 3E                  <1>           db 00111110b
    26                              <1> 
    27 000000B8 FF                  <1> char_2    db 11111111b
    28 000000B9 01                  <1>           db 00000001b
    29 000000BA 01                  <1>           db 00000001b
    30 000000BB FF                  <1>           db 11111111b
    31 000000BC 80                  <1>           db 10000000b
    32 000000BD 80                  <1>           db 10000000b
    33 000000BE 80                  <1>           db 10000000b
    34 000000BF FF                  <1>           db 11111111b
    35                              <1> 
    36 000000C0 FE                  <1> char_3    db 11111110b
    37 000000C1 01                  <1>           db 00000001b
    38 000000C2 01                  <1>           db 00000001b
    39 000000C3 1F                  <1>           db 00011111b
    40 000000C4 01                  <1>           db 00000001b
    41 000000C5 01                  <1>           db 00000001b
    42 000000C6 01                  <1>           db 00000001b
    43 000000C7 FE                  <1>           db 11111110b
    44                              <1> 
    45 000000C8 81                  <1> char_4    db 10000001b
    46 000000C9 81                  <1>           db 10000001b
    47 000000CA 81                  <1>           db 10000001b
    48 000000CB FF                  <1>           db 11111111b
    49 000000CC 01                  <1>           db 00000001b
    50 000000CD 01                  <1>           db 00000001b
    51 000000CE 01                  <1>           db 00000001b
    52 000000CF 01                  <1>           db 00000001b
    53                              <1> 
    54 000000D0 FF                  <1> char_5    db 11111111b
    55 000000D1 80                  <1>           db 10000000b
    56 000000D2 80                  <1>           db 10000000b
    57 000000D3 FF                  <1>           db 11111111b
    58 000000D4 01                  <1>           db 00000001b
    59 000000D5 01                  <1>           db 00000001b
    60 000000D6 01                  <1>           db 00000001b
    61 000000D7 FF                  <1>           db 11111111b
    62                              <1> 
    63 000000D8 FF                  <1> char_6    db 11111111b
    64 000000D9 80                  <1>           db 10000000b
    65 000000DA 80                  <1>           db 10000000b
    66 000000DB 80                  <1>           db 10000000b
    67 000000DC FF                  <1>           db 11111111b
    68 000000DD 81                  <1>           db 10000001b
    69 000000DE 81                  <1>           db 10000001b
    70 000000DF FF                  <1>           db 11111111b
    71                              <1> 
    72 000000E0 FF                  <1> char_7    db 11111111b
    73 000000E1 01                  <1>           db 00000001b
    74 000000E2 02                  <1>           db 00000010b
    75 000000E3 04                  <1>           db 00000100b
    76 000000E4 08                  <1>           db 00001000b
    77 000000E5 08                  <1>           db 00001000b
    78 000000E6 08                  <1>           db 00001000b
    79 000000E7 08                  <1>           db 00001000b
    80                              <1> 
    81 000000E8 FF                  <1> char_8    db 11111111b
    82 000000E9 81                  <1>           db 10000001b
    83 000000EA 81                  <1>           db 10000001b
    84 000000EB FF                  <1>           db 11111111b
    85 000000EC 81                  <1>           db 10000001b
    86 000000ED 81                  <1>           db 10000001b
    87 000000EE 81                  <1>           db 10000001b
    88 000000EF FF                  <1>           db 11111111b
    89                              <1> 
    90 000000F0 FF                  <1> char_9    db 11111111b
    91 000000F1 81                  <1>           db 10000001b
    92 000000F2 81                  <1>           db 10000001b
    93 000000F3 FF                  <1>           db 11111111b
    94 000000F4 01                  <1>           db 00000001b
    95 000000F5 01                  <1>           db 00000001b
    96 000000F6 01                  <1>           db 00000001b
    97 000000F7 7E                  <1>           db 01111110b
    98                              <1> 
    99                              <1> 
   100 000000F8 7E                  <1> char_A    db 01111110b
   101 000000F9 81                  <1>           db 10000001b
   102 000000FA 81                  <1>           db 10000001b
   103 000000FB 81                  <1>           db 10000001b
   104 000000FC FF                  <1>           db 11111111b
   105 000000FD 81                  <1>           db 10000001b
   106 000000FE 81                  <1>           db 10000001b
   107 000000FF 81                  <1>           db 10000001b
   108                              <1> 
   109 00000100 FE                  <1> char_B    db 11111110b
   110 00000101 82                  <1>           db 10000010b
   111 00000102 82                  <1>           db 10000010b
   112 00000103 FE                  <1>           db 11111110b
   113 00000104 81                  <1>           db 10000001b
   114 00000105 81                  <1>           db 10000001b
   115 00000106 81                  <1>           db 10000001b
   116 00000107 FF                  <1>           db 11111111b
   117                              <1> 
   118 00000108 FF                  <1> char_C    db 11111111b
   119 00000109 81                  <1>           db 10000001b
   120 0000010A 80                  <1>           db 10000000b
   121 0000010B 80                  <1>           db 10000000b
   122 0000010C 80                  <1>           db 10000000b
   123 0000010D 80                  <1>           db 10000000b
   124 0000010E 81                  <1>           db 10000001b
   125 0000010F FF                  <1>           db 11111111b
   126                              <1> 
   127 00000110 FE                  <1> char_D    db 11111110b
   128 00000111 81                  <1>           db 10000001b
   129 00000112 81                  <1>           db 10000001b
   130 00000113 81                  <1>           db 10000001b
   131 00000114 81                  <1>           db 10000001b
   132 00000115 81                  <1>           db 10000001b
   133 00000116 81                  <1>           db 10000001b
   134 00000117 FE                  <1>           db 11111110b
   135                              <1> 
   136 00000118 FF                  <1> char_E    db 11111111b
   137 00000119 80                  <1>           db 10000000b
   138 0000011A 80                  <1>           db 10000000b
   139 0000011B FC                  <1>           db 11111100b
   140 0000011C 80                  <1>           db 10000000b
   141 0000011D 80                  <1>           db 10000000b
   142 0000011E 80                  <1>           db 10000000b
   143 0000011F FF                  <1>           db 11111111b
   144                              <1> 
   145 00000120 FF                  <1> char_F    db 11111111b
   146 00000121 80                  <1>           db 10000000b
   147 00000122 80                  <1>           db 10000000b
   148 00000123 FC                  <1>           db 11111100b
   149 00000124 80                  <1>           db 10000000b
   150 00000125 80                  <1>           db 10000000b
   151 00000126 80                  <1>           db 10000000b
   152 00000127 80                  <1>           db 10000000b
   153                              <1> 
   154 00000128 AA                  <1> char_default  db 10101010b
   155 00000129 AA                  <1>           db 10101010b
   156 0000012A AA                  <1>           db 10101010b
   157 0000012B AA                  <1>           db 10101010b
   158 0000012C AA                  <1>           db 10101010b
   159 0000012D AA                  <1>           db 10101010b
   160 0000012E AA                  <1>           db 10101010b
   161 0000012F AA                  <1>           db 10101010b
   398                                  %include "./draw/keyboard_data.asm"
     1                              <1> section .data
     2                              <1> ; align 4
     3                              <1> ; KEYBOARD INPUT CODE
     4 00000130 0000                <1> key_code dw 0
     5 00000132 0000                <1> key_code_ah dw 0
     6 00000134 0000                <1> key_code_al dw 0
     7                              <1> ; mov WORD [key_code_ah], 0
     8                              <1> 
     9                              <1> 
    10                              <1> 
    11                              <1> ; key-flags indicating that the key is currently pressed
    12 00000136 0000                <1> press_event dw 0 ; 1 = pressed, 0 = released
    13 00000138 0000                <1> w_pressed dw 0
    14 0000013A C706[3801]0000      <1> mov WORD [w_pressed], 0x0000
    15 00000140 0000                <1> a_pressed dw 0
    16 00000142 0000                <1> s_pressed dw 0
    17 00000144 0000                <1> d_pressed dw 0
    18                              <1> 
    19 00000146 00<rep 100h>        <1> cursor_buffer times 256 db 0
    20 00000246 0000                <1> ascii_current_press dw 0
    21 00000248 0000                <1> cursor_count dw 0
    22 0000024A 0000                <1> cursor_c dw 0
    23 0000024C 1300                <1> cursor_r dw 19
    24 0000024E 0A00                <1> cursor_w dw 10
    25 00000250 0A00                <1> cursor_h dw 10
    26                              <1> 
   399                                  
   400                                  
   401                                  ; section .data
   402                                  
   403                                  
   404                                  ; ; NEEDED TO DEFINE THE ARRAY HERE WITHOUT A SECTION-LABEL TO BE ABLE TO USE THE ARRAY!
   405 00000252 0A0014001E00280032-     word_array: dw 10, 20, 30, 40, 50 ; An array of 5 bytes
   405 0000025B 00                 
   406                                  ; ; word_buffer: resw 5 ; 10 bytes without specifying initial value
   407                                  
   408                                  ; byte_array: times 10 db 0 ; 10 bytes initaliezed to '0'
   409                                  ; byte_array_size: equ 10
   410                                  
   411                                  ; frame_buff: times 64 db 0 ; Cant use the 64k that I want for a full framebuffer..
   412                                  ; ; frame_buff_size: equ 640
   413                                  
   414                                  ; framebuffer_64k: 0x7E00
   415                                  ; Initialize buffer location
   416                                      ; mov ax, 0x7E00     ; Address right after boot sector
   417                                      ; mov es, ax         ; Set extra segment
   418                                      ; xor di, di         ; Zero offset
   419                                      ; mov cx, 10000        ; Number of bytes to clear
   420                                      ; xor al, al         ; Value to fill (zero)
   421                                      ; rep stosb          ; Clear the buffer
   422                                  
   423                                  
   424                                  
   425                                  ; PIXEL COORIDINATES
   426 0000025C 0000                    pixel_x dw 0
   427 0000025E 0000                    pixel_y dw 0
   428                                  
   429                                  
   430                                  ; player location
   431 00000260 0000                    x dw 0
   432 00000262 0000                    y dw 0
   433                                  ; mov WORD [y], 0
   434                                  ; mov WORD [x], 0
   435                                  
   436                                  ; player position : NOTE: INTIAL VALUE WILL ALWAYS BE 0 WHEN DEFINED IN .data!
   437 00000264 A000                    player_position_x dw 0xA0
   438 00000266 6000                    player_position_y dw 0x60
   439                                  ; mov word [player_position_x], 0xA0
   440                                  ; mov word [player_position_y], 0x60
   441                                  
   442                                  ; call render
   443                                  ; call render
   444                                  ; call render
   445                                  ; call render
   446                                  ; call render
   447                                  
   448                                  
   449                                  
   450                                  ; Interrupt Data
   451                                  PIT_CONTROL_PORT  equ 0x43
   452                                  PIT_CHANNEL_0     equ 0x40
   453                                  IRQ0_VECTOR       equ 0x08
   454                                  
   455                                  ; used for restoring irq0 state -- implementation in 'timer_interrupt.asm'
   456 00000268 0000                    old_irq0_offset dw 0x0000
   457 0000026A 0000                    old_irq0_segment dw 0x0000
   458                                  ; PROBLEM WHEN INCLUDING THESE VARIABLES IN TEXT SEGMENT!
   459                                  ; Uncommenting the blow definition will be interpereted as an instruction rather than data, blocking the vm!
   460                                  ; old_irq0_segment dw 0x8bfa 
   461                                  
   462                                  ; timing interrupt counter
   463 0000026C 0000                    tick_count dw 0
   464                                  
   465                                  
   466                                  
   467                                  ;   Triangulation!
   468                                  ;   
   469                                  ; align 4
   470 0000026E 000016430000A04200-     position dd 150.0, 80.0, 0.0
   470 00000277 000000             
   471 0000027A 000000000000000000-     velocity dd 0.0, 0.0, 0.0
   471 00000283 000000             
   472                                  ;
   473                                  ;
   474                                  
   475                                  
   476                                  ;
   477                                  ; GEOMETRY - fixed triangles that will be transformed and rendered
   478                                  ; 
   479                                  ; First triangle
   480                                  ; 36 bytes          ; x0, y0, z0  &  x1, y1, z1 & x2, y2, z2
   481 00000286 000070420000704200-     triangle_1  dd      60.0,   60.0,   0.0,                     110.0,  80.0,   0.0,                     60.0,   110.0,  0.0
   481 0000028F 0000000000DC420000-
   481 00000298 A04200000000000070-
   481 000002A1 420000DC4200000000 
   484                                  
   485                                  
   486                                  my_data_end:
